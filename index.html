<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ТИМ</title>

  <!-- PWA -->
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#f5f6f8">

  <!-- iOS standalone -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="ТИМ">

  <!-- Icons -->
  <link rel="icon" href="/icon-192.png">
  <link rel="apple-touch-icon" href="/icon-192.png">

  <style>
    :root{
      /* LIGHT THEME */
      --bg:#f5f6f8;
      --panel:#ffffff;
      --border:#d8dbe0;

      --text:#111317;
      --muted:#667085;

      --btn:#2d6cff;
      --btnText:#fff;

      --inputBg:#f1f3f5;

      --ok:#2f7d32;
      --danger:#b3261e;

      --chip:#f7f7f9;
      --chipBd:#e3e6eb;

      --shadow: 0 10px 30px rgba(16,24,40,.18);

      --msgMeBg:#e8f0ff;
      --msgMeBd:#cfe0ff;
      --msgBotBg:#f6f7f9;
      --msgBotBd:#e3e6eb;

      --hover:#f0f2f5;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Arial,sans-serif;
      background:var(--bg); color:var(--text);
      /* full width */
      display:block;
    }

    /* iOS safe areas */
    .safeTop{ padding-top: env(safe-area-inset-top); }
    .safeBottom{ padding-bottom: env(safe-area-inset-bottom); }

    .container{
      width:100%;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      padding:12px;
      gap:12px;
    }

    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      gap:10px;
      box-shadow: var(--shadow);
    }

    .leftHead{display:flex; align-items:center; gap:10px; min-width:0}
    .title{font-weight:800; font-size:16px; white-space:nowrap}
    .crumb{font-size:12px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:56vw}

    .actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:nowrap;
      justify-content:flex-end;
      position:relative; /* for menu */
    }

    button{
      padding:10px 12px;
      border-radius:12px;
      border:none;
      background:var(--btn);
      color:var(--btnText);
      font-weight:800;
      cursor:pointer;
    }
    button:disabled{opacity:.6; cursor:not-allowed}
    .btnGhost{
      background:transparent;
      border:1px solid var(--border);
      color:var(--text);
      font-weight:800;
    }
    .btnDanger{
      background:transparent;
      border:1px solid rgba(179,38,30,.45);
      color:var(--danger);
      font-weight:800;
    }
    .btnOk{
      background:transparent;
      border:1px solid rgba(47,125,50,.45);
      color:var(--ok);
      font-weight:800;
    }

    /* icon buttons (header) */
    .iconBtn{
      width:42px;
      height:42px;
      padding:0;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .iconBtn svg{ width:20px; height:20px; display:block; }
    .iconBtnGhost{
      background:transparent;
      border:1px solid var(--border);
      color:var(--text);
    }
    .iconBtnPrimary{
      background:var(--btn);
      border:1px solid rgba(45,108,255,.25);
      box-shadow: 0 8px 18px rgba(45,108,255,.18);
    }
    .iconBtnPrimary svg path{ stroke:#fff; }

    /* Add menu */
    .menu{
      position:absolute;
      top:48px;
      right:0;
      width:220px;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:none;
      z-index:50;
    }
    .menu button{
      width:100%;
      border:0;
      border-radius:0;
      background:transparent;
      color:var(--text);
      padding:12px 12px;
      font-weight:900;
      text-align:left;
      cursor:pointer;
    }
    .menu button:hover{ background:var(--hover); }
    .menu .sep{
      height:1px;
      background:var(--border);
      margin:0;
    }
    .menu .dangerItem{ color:var(--danger); }

    /* Main panel */
    .panel{
      flex:1;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      position:relative;
      box-shadow: var(--shadow);
    }

    /* Lists */
    .list{display:flex; flex-direction:column; gap:10px}
    .card{
      background:var(--chip);
      border:1px solid var(--chipBd);
      border-radius:14px;
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .card .meta{min-width:0}
    .card .name{
      font-weight:900;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:70vw;
    }
    .card .sub{
      font-size:12px; color:var(--muted); margin-top:4px;
      display:flex; gap:10px; flex-wrap:wrap;
    }
    .pill{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--chipBd);
      color:var(--muted);
      background:#fff;
    }
    .empty{
      color:var(--muted);
      padding:18px;
      border:1px dashed var(--border);
      border-radius:14px;
      text-align:center;
      line-height:1.4;
      background:#fff;
    }

    /* Item list inside puchok */
    .itemRow{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      background:#fff;
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
    }
    .itemRow:hover{background:var(--hover)}
    .itemLeft{min-width:0; display:flex; gap:10px; align-items:center}
    .thumb{
      width:44px; height:44px; border-radius:12px;
      border:1px solid var(--border);
      background:#f3f4f6;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
      flex:0 0 auto;
    }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block}
    .thumb .ico{ width:22px; height:22px; opacity:.75; }
    .itemText{min-width:0}
    .itemTitle{
      font-weight:900;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:62vw;
    }
    .itemDesc{
      margin-top:4px;
      font-size:12px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:72vw;
    }
    .tagText{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #cfe0ff;
      color:#1f4fd6;
      background:#e8f0ff;
      white-space:nowrap;
      font-weight:800;
    }
    .tagFile{ border-color:#f4d6a6; color:#9a5a00; background:#fff4e1; }
    .tagImg{ border-color:#c8f1d2; color:#176c2c; background:#e9f9ee; }
    .tagAudio{ border-color:#f3c7d0; color:#8a1830; background:#fdecef; }

    /* Chat dock */
    .dock{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .dockHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      gap:10px;
    }
    .dockTitle{font-weight:900}
    .dockSmall{
      font-size:12px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:60vw
    }
    .dockBody{
      max-height:38vh;
      overflow:auto;
      padding:12px;
    }

    .composer{
      display:flex; gap:10px;
      padding:12px;
      border-top:1px solid var(--border);
      background:#fafbfc;
      align-items:center;
    }
    input{
      width:100%;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--inputBg);
      color:var(--text);
      outline:none;
      font-size:16px;
    }
    .sendBtn{
      width:44px; height:44px;
      padding:0;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
      box-shadow: 0 8px 18px rgba(45,108,255,.22);
    }
    .sendBtn svg{width:20px; height:20px; display:block}

    /* Messages */
    .msg{
      padding:10px 12px;
      border-radius:14px;
      margin:10px 0;
      max-width:92%;
      line-height:1.35;
      white-space:pre-wrap;
      word-wrap:break-word;
      border:1px solid transparent;
      position:relative;
      background:#fff;
    }
    .me{margin-left:auto; background:var(--msgMeBg); border-color:var(--msgMeBd)}
    .bot{margin-right:auto; background:var(--msgBotBg); border-color:var(--msgBotBd)}
    .err{margin-right:auto; background:#fff1f1; border-color:#ffd0d0; color:#7a0b0b}
    .msgTools{
      margin-top:8px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .miniBtn{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      font-weight:900;
      cursor:pointer;
      font-size:13px;
    }
    .miniBtnOk{border-color:rgba(47,125,50,.35); color:var(--ok)}
    .miniBtnDanger{border-color:rgba(179,38,30,.35); color:var(--danger)}

    /* Modal */
    .modalWrap{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    .modal{
      width:min(860px, 100%);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .modalHead{
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--border);
    }
    .modalTitle{
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:68vw;
    }
    .modalBody{padding:12px}
    textarea{
      width:100%;
      min-height:46vh;
      resize:vertical;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--inputBg);
      color:var(--text);
      outline:none;
      font-size:15px;
      line-height:1.4;
      display:none;
    }
    .viewer{
      display:none;
      width:100%;
      min-height:46vh;
      border-radius:14px;
      border:1px solid var(--border);
      background:#fff;
      overflow:auto;
      padding:12px;
    }
    .viewer img{
      max-width:100%;
      height:auto;
      border-radius:12px;
      border:1px solid var(--border);
      display:block;
      margin:0 auto;
    }
    .viewer .fileRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      border:1px solid var(--border);
      border-radius:14px;
      background:#fff;
    }
    .viewer .fileMeta{min-width:0}
    .viewer .fileName{
      font-weight:900;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:62vw;
    }
    .viewer .fileSub{font-size:12px; color:var(--muted); margin-top:4px}
    .viewer .viewerActions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:10px}

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      justify-content:flex-end;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
      line-height:1.35;
    }
    .recBadge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:900;
      color:#7a0b0b;
      background:#fff1f1;
      border:1px solid #ffd0d0;
      padding:8px 10px;
      border-radius:999px;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;background:#e11d48;
      box-shadow: 0 0 0 4px rgba(225,29,72,.15);
    }

    @media (min-width: 900px){
      .container{ padding:16px 18px; }
    }
  </style>
</head>

<body>
  <div class="container safeTop safeBottom">
    <header>
      <div class="leftHead">
        <button id="backBtn" class="btnGhost" style="display:none;">←</button>
        <div>
          <div class="title" id="headTitle">ТИМ</div>
          <div class="crumb" id="headCrumb">Пучки + чат</div>
        </div>
      </div>

      <div class="actions" id="headActions">
        <button id="newPuchokBtn">+ Пучок</button>

        <!-- compact controls shown inside puchok -->
        <button id="editPuchokBtn" class="iconBtn iconBtnGhost" style="display:none;" title="Переименовать">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M4 20h4l10.5-10.5a2 2 0 0 0 0-3L16.5 4.5a2 2 0 0 0-3 0L3 15v5Z" stroke="#111317" stroke-width="2" stroke-linejoin="round"/>
            <path d="M13.5 6.5l4 4" stroke="#111317" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>

        <button id="addMenuBtn" class="iconBtn iconBtnPrimary" style="display:none;" title="Добавить">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 5v14M5 12h14" stroke="white" stroke-width="2.4" stroke-linecap="round"/>
          </svg>
        </button>

        <div id="addMenu" class="menu" role="menu" aria-hidden="true">
          <button id="menuAddText">Добавить текст</button>
          <button id="menuAddFile">Добавить файл/фото</button>
          <button id="menuAddAudio">Добавить аудио</button>
          <div class="sep"></div>
          <button id="menuDeletePuchok" class="dangerItem">Удалить пучок</button>
        </div>
      </div>
    </header>

    <div class="panel" id="mainPanel"></div>

    <div class="dock" id="chatDock">
      <div class="dockHead">
        <div>
          <div class="dockTitle">Чат</div>
          <div class="dockSmall" id="chatHint">Пишешь — отправляю в Worker (/chat). Ответ можно сохранить “В пучок”.</div>
        </div>
        <button id="clearChatBtn" class="btnGhost">Очистить</button>
      </div>

      <div class="dockBody" id="chat"></div>

      <div class="composer">
        <input id="input" type="text" placeholder="Напиши сообщение..." autocomplete="off" />
        <button id="send" class="sendBtn" title="Отправить">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M4.5 12L19 5.5L13 19L11.8 13.7L4.5 12Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- One picker for everything (images included) -->
  <input id="filePicker" type="file" style="display:none" />

  <!-- Modal (universal) -->
  <div class="modalWrap" id="modalWrap">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Элемент</div>
        <div class="actions">
          <button id="modalClose" class="btnGhost">Закрыть</button>
        </div>
      </div>
      <div class="modalBody">
        <textarea id="modalTextarea" spellcheck="false"></textarea>
        <div class="viewer" id="modalViewer"></div>

        <div class="row" id="modalRow">
          <button id="modalDelete" class="btnDanger">Удалить</button>
          <button id="modalSave" class="btnOk">Сохранить</button>
        </div>

        <div class="hint" id="modalHint">—</div>
      </div>
    </div>
  </div>

<script>
/** ===========================
 *  CONFIG
 *  =========================== */
const WORKER_URL = "https://gptim24.timashevanatoly10.workers.dev";
const STORAGE_KEY = "tim_puchki_v2"; // same structure as you have

// IndexedDB for blobs
const IDB_NAME = "tim_puchki_blobs";
const IDB_STORE = "blobs";

/** ===========================
 *  DOM
 *  =========================== */
const mainPanel = document.getElementById("mainPanel");
const backBtn = document.getElementById("backBtn");
const headTitle = document.getElementById("headTitle");
const headCrumb = document.getElementById("headCrumb");

const newPuchokBtn = document.getElementById("newPuchokBtn");

const editPuchokBtn = document.getElementById("editPuchokBtn");
const addMenuBtn = document.getElementById("addMenuBtn");
const addMenu = document.getElementById("addMenu");
const menuAddText = document.getElementById("menuAddText");
const menuAddFile = document.getElementById("menuAddFile");
const menuAddAudio = document.getElementById("menuAddAudio");
const menuDeletePuchok = document.getElementById("menuDeletePuchok");

const chat = document.getElementById("chat");
const input = document.getElementById("input");
const send = document.getElementById("send");
const clearChatBtn = document.getElementById("clearChatBtn");
const chatHint = document.getElementById("chatHint");

const filePicker = document.getElementById("filePicker");

const modalWrap = document.getElementById("modalWrap");
const modalTitle = document.getElementById("modalTitle");
const modalTextarea = document.getElementById("modalTextarea");
const modalViewer = document.getElementById("modalViewer");
const modalClose = document.getElementById("modalClose");
const modalSave = document.getElementById("modalSave");
const modalDelete = document.getElementById("modalDelete");
const modalHint = document.getElementById("modalHint");
const modalRow = document.getElementById("modalRow");

/** ===========================
 *  STATE
 *  =========================== */
let db = loadDB();
let currentPuchokId = null; // null = list screen
let openItemId = null;
let openItemType = null;

let mediaRecorder = null;
let recChunks = [];
let isRecording = false;
let currentAudioAppendTarget = null; // { pId, itemId }

/** ===========================
 *  IndexedDB helpers
 *  =========================== */
function idbOpen(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(IDB_NAME, 1);
    req.onupgradeneeded = () => {
      const d = req.result;
      if(!d.objectStoreNames.contains(IDB_STORE)){
        d.createObjectStore(IDB_STORE, { keyPath: "key" });
      }
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbPutBlob(key, blob){
  const d = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = d.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).put({ key, blob });
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error);
  });
}
async function idbGetBlob(key){
  const d = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = d.transaction(IDB_STORE, "readonly");
    const req = tx.objectStore(IDB_STORE).get(key);
    req.onsuccess = ()=> resolve(req.result ? req.result.blob : null);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbDelete(key){
  const d = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = d.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).delete(key);
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error);
  });
}

/** ===========================
 *  HELPERS
 *  =========================== */
function nowISO(){ return new Date().toISOString(); }
function uid(){
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}
function safeTitleFromText(t){
  const s = (t || "").toString().trim().replace(/\s+/g," ");
  return s.length > 48 ? s.slice(0, 48) + "…" : (s || "Без названия");
}
function fmtDate(iso){
  try{
    const d = new Date(iso);
    return d.toLocaleString(undefined, { year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit" });
  }catch{ return iso; }
}
function fmtBytes(bytes){
  const b = Number(bytes || 0);
  if(!b) return "0 B";
  const units = ["B","KB","MB","GB"];
  let i = 0; let n = b;
  while(n >= 1024 && i < units.length-1){ n/=1024; i++; }
  return `${n.toFixed(n>=10||i===0?0:1)} ${units[i]}`;
}
function icoSVG(kind){
  const common = `class="ico" viewBox="0 0 24 24" fill="none"`;
  if(kind==="file"){
    return `<svg ${common}><path d="M7 3h7l3 3v15H7V3Z" stroke="#111317" stroke-width="2"/><path d="M14 3v6h6" stroke="#111317" stroke-width="2"/></svg>`;
  }
  if(kind==="audio"){
    return `<svg ${common}><path d="M12 3v12" stroke="#111317" stroke-width="2"/><path d="M8 7v8" stroke="#111317" stroke-width="2"/><path d="M16 7v8" stroke="#111317" stroke-width="2"/><path d="M5 11v4" stroke="#111317" stroke-width="2"/><path d="M19 11v4" stroke="#111317" stroke-width="2"/></svg>`;
  }
  return `<svg ${common}><path d="M4 6h16v12H4V6Z" stroke="#111317" stroke-width="2"/><path d="M8 11l2.5 3 2-2 3.5 4" stroke="#111317" stroke-width="2" stroke-linejoin="round"/><path d="M9 9.5h.01" stroke="#111317" stroke-width="3" stroke-linecap="round"/></svg>`;
}
function typeLabel(it){
  if(it.type==="image") return { text:"Фото", cls:"tagText tagImg" };
  if(it.type==="file") return { text:"Файл", cls:"tagText tagFile" };
  if(it.type==="audio") return { text:"Аудио", cls:"tagText tagAudio" };
  return { text:"Текст", cls:"tagText" };
}
function escapeHTML(s){
  return (s||"").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/** ===========================
 *  DB (localStorage metadata)
 *  =========================== */
function loadDB(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return { puchki: [] };
    const parsed = JSON.parse(raw);
    if(!parsed || !Array.isArray(parsed.puchki)) return { puchki: [] };
    parsed.puchki.forEach(p => { if(!Array.isArray(p.items)) p.items = []; });
    return parsed;
  }catch{
    return { puchki: [] };
  }
}
function saveDB(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(db));
}
function getPuchok(id){
  return db.puchki.find(p => p.id === id) || null;
}
function getItem(pId, itemId){
  const p = getPuchok(pId);
  if(!p) return null;
  return (p.items || []).find(x => x.id === itemId) || null;
}

/** ===========================
 *  MENU (Add)
 *  =========================== */
function closeAddMenu(){
  addMenu.style.display = "none";
  addMenu.setAttribute("aria-hidden","true");
}
function toggleAddMenu(){
  if(addMenu.style.display === "block"){
    closeAddMenu();
  }else{
    addMenu.style.display = "block";
    addMenu.setAttribute("aria-hidden","false");
  }
}

/** ===========================
 *  UI HEADER
 *  =========================== */
function setHeaderForList(){
  backBtn.style.display = "none";
  headTitle.textContent = "ТИМ";
  headCrumb.textContent = "Пучки + чат";

  editPuchokBtn.style.display = "none";
  addMenuBtn.style.display = "none";
  closeAddMenu();

  newPuchokBtn.style.display = "";

  chatHint.textContent = "Совет: сначала открой пучок → тогда “В пучок” будет сохранять ответы прямо туда.";
}
function setHeaderForPuchok(p){
  backBtn.style.display = "";
  headTitle.textContent = "Пучок";
  headCrumb.textContent = p.title || "Без названия";

  newPuchokBtn.style.display = "none";
  editPuchokBtn.style.display = "";
  addMenuBtn.style.display = "";
  closeAddMenu();

  chatHint.textContent = "Ты в пучке: ответы бота можно сохранять кнопкой “В пучок”.";
}

/** ===========================
 *  UI RENDER
 *  =========================== */
function render(){
  mainPanel.innerHTML = "";
  if(!currentPuchokId){
    setHeaderForList();
    renderPuchokList();
  }else{
    const p = getPuchok(currentPuchokId);
    if(!p){
      currentPuchokId = null;
      render();
      return;
    }
    setHeaderForPuchok(p);
    renderPuchokInside(p);
  }
}

function renderPuchokList(){
  const wrap = document.createElement("div");
  wrap.className = "list";

  if(db.puchki.length === 0){
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = "Пока нет пучков.<br>Нажми <b>+ Пучок</b>, потом зайди внутрь и сохраняй туда ответы / заметки / файлы / аудио.";
    wrap.appendChild(empty);
  }else{
    const sorted = [...db.puchki].sort((a,b)=> (b.updatedAt||b.createdAt||"").localeCompare(a.updatedAt||a.createdAt||""));
    for(const p of sorted){
      const card = document.createElement("div");
      card.className = "card";

      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = p.title || "Без названия";

      const sub = document.createElement("div");
      sub.className = "sub";
      const count = (p.items || []).length;

      const pill1 = document.createElement("span");
      pill1.className = "pill";
      pill1.textContent = `Элементов: ${count}`;

      const pill2 = document.createElement("span");
      pill2.className = "pill";
      pill2.textContent = `Обновлён: ${fmtDate(p.updatedAt || p.createdAt || nowISO())}`;

      sub.appendChild(pill1);
      sub.appendChild(pill2);

      meta.appendChild(name);
      meta.appendChild(sub);

      const btn = document.createElement("button");
      btn.className = "btnGhost";
      btn.textContent = "Открыть";
      btn.addEventListener("click", () => openPuchok(p.id));

      card.appendChild(meta);
      card.appendChild(btn);
      wrap.appendChild(card);
    }
  }

  mainPanel.appendChild(wrap);
}

function renderPuchokInside(p){
  const wrap = document.createElement("div");
  wrap.className = "list";

  if((p.items || []).length === 0){
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = "Внутри пусто.<br>Нажми <b>+</b> сверху справа → добавь текст / файл / аудио.";
    wrap.appendChild(empty);
  }else{
    const sorted = [...p.items].sort((a,b)=> (b.updatedAt||b.createdAt||"").localeCompare(a.updatedAt||a.createdAt||""));
    for(const it of sorted){
      const row = document.createElement("div");
      row.className = "itemRow";
      row.addEventListener("click", () => openItem(p.id, it.id));

      const left = document.createElement("div");
      left.className = "itemLeft";

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      if(it.type === "image" && it.thumbKey){
        thumb.innerHTML = `<span style="color:#98a2b3;font-size:12px;font-weight:900">…</span>`;
        (async()=>{
          const b = await idbGetBlob(it.thumbKey);
          if(b){
            const url = URL.createObjectURL(b);
            const img = document.createElement("img");
            img.src = url;
            img.onload = ()=> URL.revokeObjectURL(url);
            thumb.innerHTML = "";
            thumb.appendChild(img);
          }else{
            thumb.innerHTML = icoSVG("image");
          }
        })();
      }else{
        thumb.innerHTML = icoSVG(it.type==="file" ? "file" : it.type==="audio" ? "audio" : "image");
      }

      const textWrap = document.createElement("div");
      textWrap.className = "itemText";

      const title = document.createElement("div");
      title.className = "itemTitle";
      title.textContent = it.title || "Элемент";

      const desc = document.createElement("div");
      desc.className = "itemDesc";

      if(it.type === "text"){
        const preview = (it.content || "").toString().trim().replace(/\s+/g," ");
        desc.textContent = preview ? (preview.length > 90 ? preview.slice(0,90)+"…" : preview) : "Пусто";
      }else if(it.type === "image"){
        desc.textContent = `${fmtBytes(it.size)} • ${fmtDate(it.createdAt || it.updatedAt || nowISO())}`;
      }else if(it.type === "file"){
        desc.textContent = `${fmtBytes(it.size)} • ${it.mime || "file"} • ${fmtDate(it.createdAt || it.updatedAt || nowISO())}`;
      }else if(it.type === "audio"){
        const segs = (it.segments || []).length;
        const total = (it.segments || []).reduce((s,x)=> s + (x.size || 0), 0);
        desc.textContent = `Сегментов: ${segs} • ${fmtBytes(total)} • ${fmtDate(it.createdAt || it.updatedAt || nowISO())}`;
      }else{
        desc.textContent = fmtDate(it.createdAt || it.updatedAt || nowISO());
      }

      textWrap.appendChild(title);
      textWrap.appendChild(desc);

      left.appendChild(thumb);
      left.appendChild(textWrap);

      const right = document.createElement("div");
      const t = typeLabel(it);
      right.className = t.cls;
      right.textContent = t.text;

      row.appendChild(left);
      row.appendChild(right);
      wrap.appendChild(row);
    }
  }

  mainPanel.appendChild(wrap);
}

/** ===========================
 *  NAV
 *  =========================== */
function openPuchok(id){
  currentPuchokId = id;
  render();
}
function goBack(){
  closeAddMenu();
  currentPuchokId = null;
  render();
}

/** ===========================
 *  CRUD: Puchok
 *  =========================== */
function createPuchok(){
  const name = prompt("Название пучка:", "Новый пучок");
  if(name === null) return;
  const p = {
    id: uid(),
    title: (name || "").trim() || "Новый пучок",
    createdAt: nowISO(),
    updatedAt: nowISO(),
    items: []
  };
  db.puchki.push(p);
  saveDB();
  openPuchok(p.id);
}
function renameCurrentPuchok(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  const name = prompt("Новое название пучка:", p.title || "");
  if(name === null) return;
  p.title = (name || "").trim() || "Без названия";
  p.updatedAt = nowISO();
  saveDB();
  render();
}
async function deleteCurrentPuchok(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  closeAddMenu();
  const ok = confirm(`Удалить пучок “${p.title || "Без названия"}”?`);
  if(!ok) return;

  for(const it of (p.items || [])){
    await cleanupItemBlobs(it);
  }

  db.puchki = db.puchki.filter(x => x.id !== p.id);
  saveDB();
  currentPuchokId = null;
  render();
}

/** ===========================
 *  CRUD: Items
 *  =========================== */
function addTextItemToCurrent(initialText = ""){
  const p = getPuchok(currentPuchokId);
  if(!p){
    alert("Сначала открой пучок — тогда можно добавлять туда элементы.");
    return;
  }
  const it = {
    id: uid(),
    type: "text",
    title: safeTitleFromText(initialText) || "Текст",
    content: (initialText || "").toString(),
    createdAt: nowISO(),
    updatedAt: nowISO()
  };
  p.items.push(it);
  p.updatedAt = nowISO();
  saveDB();
  render();
  openItem(p.id, it.id);
}

async function addFileItemToCurrent(file){
  const p = getPuchok(currentPuchokId);
  if(!p){
    alert("Сначала открой пучок — тогда можно добавлять туда элементы.");
    return;
  }

  const isImg = (file.type || "").startsWith("image/");
  const id = uid();
  const blobKey = `blob:${id}:main`;
  await idbPutBlob(blobKey, file);

  let it;
  if(isImg){
    const thumbKey = `blob:${id}:thumb`;
    await idbPutBlob(thumbKey, file); // simple thumb = original (fast)
    it = {
      id,
      type: "image",
      title: file.name ? file.name : "Фото",
      blobKey,
      thumbKey,
      mime: file.type || "image/*",
      size: file.size || 0,
      createdAt: nowISO(),
      updatedAt: nowISO()
    };
  }else{
    it = {
      id,
      type: "file",
      title: file.name || "Файл",
      blobKey,
      mime: file.type || "application/octet-stream",
      size: file.size || 0,
      createdAt: nowISO(),
      updatedAt: nowISO()
    };
  }

  p.items.push(it);
  p.updatedAt = nowISO();
  saveDB();
  render();
  openItem(p.id, it.id);
}

async function createAudioItemAndRecord(){
  const p = getPuchok(currentPuchokId);
  if(!p){
    alert("Сначала открой пучок — тогда можно добавлять туда элементы.");
    return;
  }
  const id = uid();
  const it = {
    id,
    type: "audio",
    title: `Аудио ${new Date().toLocaleDateString()}`,
    segments: [],
    createdAt: nowISO(),
    updatedAt: nowISO()
  };
  p.items.push(it);
  p.updatedAt = nowISO();
  saveDB();
  render();

  await openItem(p.id, it.id);
  await startRecordingToAudioItem(p.id, it.id);
}

/** ===========================
 *  MODAL / OPEN ITEM
 *  =========================== */
function stopAnyRecordingSafely(){
  try{
    if(mediaRecorder && isRecording){
      mediaRecorder.stop();
    }
  }catch{}
}

function closeModal(){
  stopAnyRecordingSafely();
  modalWrap.style.display = "none";
  modalTextarea.style.display = "none";
  modalViewer.style.display = "none";
  modalViewer.innerHTML = "";
  openItemId = null;
  openItemType = null;
  // do NOT null currentAudioAppendTarget here; it's handled by onstop
}

async function openItem(puchokId, itemId){
  const p = getPuchok(puchokId);
  if(!p) return;
  const it = (p.items || []).find(x => x.id === itemId);
  if(!it) return;

  openItemId = itemId;
  openItemType = it.type;

  modalTitle.textContent = it.title || "Элемент";
  modalHint.textContent = "";
  modalViewer.innerHTML = "";

  modalDelete.style.display = "";
  modalSave.style.display = "none";

  if(it.type === "text"){
    modalTextarea.style.display = "block";
    modalViewer.style.display = "none";
    modalTextarea.value = it.content || "";
    modalSave.style.display = "";
    modalHint.textContent = "Текст можно редактировать и сохранять.";
    modalWrap.style.display = "flex";
    setTimeout(()=> modalTextarea.focus(), 50);
    return;
  }

  modalTextarea.style.display = "none";
  modalViewer.style.display = "block";
  modalWrap.style.display = "flex";

  if(it.type === "image"){
    modalHint.textContent = "Фото хранится локально (IndexedDB).";
    const b = await idbGetBlob(it.blobKey);
    if(!b){
      modalViewer.innerHTML = `<div class="empty">Файл не найден в хранилище.</div>`;
      return;
    }
    const url = URL.createObjectURL(b);
    modalViewer.innerHTML = `
      <img src="${url}" alt="Фото" />
      <div class="viewerActions">
        <button class="btnGhost" id="btnOpenNewTab">Открыть</button>
        <button class="btnGhost" id="btnDownload">Скачать</button>
      </div>
    `;
    document.getElementById("btnOpenNewTab").onclick = () => window.open(url, "_blank");
    document.getElementById("btnDownload").onclick = () => {
      const a = document.createElement("a");
      a.href = url;
      a.download = it.title || "image";
      a.click();
    };
    return;
  }

  if(it.type === "file"){
    modalHint.textContent = "Файл хранится локально (IndexedDB).";
    const b = await idbGetBlob(it.blobKey);
    if(!b){
      modalViewer.innerHTML = `<div class="empty">Файл не найден в хранилище.</div>`;
      return;
    }
    const url = URL.createObjectURL(b);
    modalViewer.innerHTML = `
      <div class="fileRow">
        <div class="fileMeta">
          <div class="fileName">${escapeHTML(it.title || "Файл")}</div>
          <div class="fileSub">${escapeHTML(it.mime || "file")} • ${fmtBytes(it.size)}</div>
        </div>
        <div class="tagText tagFile">Файл</div>
      </div>
      <div class="viewerActions">
        <button class="btnGhost" id="btnOpenNewTab">Открыть</button>
        <button class="btnGhost" id="btnDownload">Скачать</button>
      </div>
      <div class="hint">Открытие зависит от типа файла и возможностей браузера. Если не откроется — используй “Скачать”.</div>
    `;
    document.getElementById("btnOpenNewTab").onclick = () => window.open(url, "_blank");
    document.getElementById("btnDownload").onclick = () => {
      const a = document.createElement("a");
      a.href = url;
      a.download = it.title || "file";
      a.click();
    };
    return;
  }

  if(it.type === "audio"){
    modalHint.textContent = "Аудио хранится сегментами. “Дозаписать” добавляет новый сегмент.";
    await renderAudioViewer(it, puchokId);
    return;
  }
}

/** ===========================
 *  MODAL SAVE/DELETE
 *  =========================== */
function saveModal(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  const it = (p.items || []).find(x => x.id === openItemId);
  if(!it || it.type !== "text") return;

  const txt = modalTextarea.value || "";
  it.content = txt;
  it.title = safeTitleFromText(txt) || (it.title || "Текст");
  it.updatedAt = nowISO();
  p.updatedAt = nowISO();
  saveDB();
  closeModal();
  render();
}

async function deleteModal(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  const it = (p.items || []).find(x => x.id === openItemId);
  if(!it) return;

  const ok = confirm("Удалить этот элемент?");
  if(!ok) return;

  stopAnyRecordingSafely();
  await cleanupItemBlobs(it);

  p.items = (p.items || []).filter(x => x.id !== it.id);
  p.updatedAt = nowISO();
  saveDB();
  closeModal();
  render();
}

async function cleanupItemBlobs(it){
  try{
    if(it.type === "image"){
      if(it.blobKey) await idbDelete(it.blobKey);
      if(it.thumbKey) await idbDelete(it.thumbKey);
    } else if(it.type === "file"){
      if(it.blobKey) await idbDelete(it.blobKey);
    } else if(it.type === "audio"){
      for(const s of (it.segments || [])){
        if(s && s.key) await idbDelete(s.key);
      }
    }
  }catch{}
}

/** ===========================
 *  AUDIO: record + append segments
 *  =========================== */
async function ensureMic(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    alert("Запись аудио не поддерживается в этом браузере.");
    return null;
  }
  try{
    return await navigator.mediaDevices.getUserMedia({ audio: true });
  }catch{
    alert("Нет доступа к микрофону.");
    return null;
  }
}

async function startRecordingToAudioItem(pId, itemId){
  const it = getItem(pId, itemId);
  const p = getPuchok(pId);
  if(!it || !p || it.type !== "audio") return;

  // if already recording something else, stop first
  if(isRecording){
    stopAnyRecordingSafely();
    return;
  }

  const stream = await ensureMic();
  if(!stream) return;

  let mime = "";
  if(MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) mime = "audio/webm;codecs=opus";
  else if(MediaRecorder.isTypeSupported("audio/webm")) mime = "audio/webm";
  else if(MediaRecorder.isTypeSupported("audio/mp4")) mime = "audio/mp4";

  recChunks = [];
  mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
  isRecording = true;
  currentAudioAppendTarget = { pId, itemId };

  mediaRecorder.ondataavailable = (ev) => {
    if(ev.data && ev.data.size > 0) recChunks.push(ev.data);
  };

  mediaRecorder.onstop = async () => {
    isRecording = false;

    try{ stream.getTracks().forEach(t=>t.stop()); }catch{}

    const target = currentAudioAppendTarget;
    currentAudioAppendTarget = null;

    if(!target) return;

    const p2 = getPuchok(target.pId);
    const it2 = getItem(target.pId, target.itemId);
    if(!p2 || !it2 || it2.type !== "audio") return;

    const blob = new Blob(recChunks, { type: (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : "audio/webm" });
    if(blob.size > 0){
      const segKey = `blob:${it2.id}:seg:${uid()}`;
      await idbPutBlob(segKey, blob);

      it2.segments = it2.segments || [];
      it2.segments.push({ key: segKey, mime: blob.type || "audio/webm", size: blob.size || 0, createdAt: nowISO() });
      it2.updatedAt = nowISO();
      p2.updatedAt = nowISO();
      saveDB();
    }

    await renderAudioViewer(it2, target.pId);
    render();
  };

  mediaRecorder.start();
  await renderAudioViewer(it, pId);
}

async function buildAudioBlobFromSegments(it){
  const segs = it.segments || [];
  if(segs.length === 0) return null;

  const blobs = [];
  for(const s of segs){
    const b = await idbGetBlob(s.key);
    if(b) blobs.push(b);
  }
  if(blobs.length === 0) return null;

  const mime = blobs[0].type || (segs[0].mime || "audio/webm");
  return new Blob(blobs, { type: mime });
}

async function renderAudioViewer(it, pId){
  if(!it || it.type !== "audio") return;

  const segs = it.segments || [];
  const total = segs.reduce((s,x)=> s + (x.size || 0), 0);

  const merged = await buildAudioBlobFromSegments(it);
  const audioURL = merged ? URL.createObjectURL(merged) : "";

  const isThisRec = isRecording && currentAudioAppendTarget && currentAudioAppendTarget.itemId === it.id;
  const recUI = isThisRec
    ? `<div class="recBadge"><span class="dot"></span>Запись…</div>`
    : "";

  modalViewer.innerHTML = `
    <div class="fileRow">
      <div class="fileMeta">
        <div class="fileName">${escapeHTML(it.title || "Аудио")}</div>
        <div class="fileSub">Сегментов: ${segs.length} • ${fmtBytes(total)}</div>
      </div>
      <div class="tagText tagAudio">Аудио</div>
    </div>

    <div style="margin-top:12px;">
      ${audioURL ? `<audio controls style="width:100%;"></audio>` : `<div class="empty">Пока нет записи. Нажми “Записать”.</div>`}
    </div>

    <div class="viewerActions">
      <button class="btnOk" id="btnRec">${isThisRec ? "Стоп" : (segs.length ? "Дозаписать" : "Записать")}</button>
      <button class="btnGhost" id="btnDownload" ${audioURL ? "" : "disabled"}>Скачать</button>
    </div>

    <div style="margin-top:10px;">${recUI}</div>

    <div class="hint" style="margin-top:10px;">
      Совет: можно записывать по частям. Каждая “Дозапись” добавляет сегмент.
    </div>
  `;

  const audioEl = modalViewer.querySelector("audio");
  if(audioEl && audioURL){
    audioEl.src = audioURL;
    audioEl.onended = ()=>{};
  }

  document.getElementById("btnRec").onclick = async () => {
    if(isThisRec){
      stopAnyRecordingSafely();
      return;
    }
    await startRecordingToAudioItem(pId, it.id);
  };

  const btnD = document.getElementById("btnDownload");
  if(btnD){
    btnD.onclick = () => {
      if(!audioURL) return;
      const a = document.createElement("a");
      a.href = audioURL;
      a.download = (it.title || "audio") + ".webm";
      a.click();
    };
  }
}

/** ===========================
 *  CHAT UI
 *  =========================== */
function addMsg(text, cls){
  const wrap = document.createElement("div");
  wrap.className = "msg " + cls;

  const body = document.createElement("div");
  body.textContent = text;
  wrap.appendChild(body);

  if(cls === "bot"){
    const tools = document.createElement("div");
    tools.className = "msgTools";

    const btnSave = document.createElement("button");
    btnSave.className = "miniBtn miniBtnOk";
    btnSave.textContent = "В пучок";
    btnSave.addEventListener("click", () => {
      if(!currentPuchokId){
        alert("Открой пучок — тогда “В пучок” сохранит ответ туда.");
        return;
      }
      addTextItemToCurrent(text);
    });

    tools.appendChild(btnSave);
    wrap.appendChild(tools);
  }

  chat.appendChild(wrap);
  chat.scrollTop = chat.scrollHeight;
}

function clearChat(){
  chat.innerHTML = "";
  addMsg("Чат очищен. Пиши сообщение — я отправлю в Worker (/chat).", "bot");
}

/** ===========================
 *  CHAT NETWORK
 *  =========================== */
async function handleSend(){
  const text = input.value.trim();
  if(!text) return;

  addMsg(text, "me");
  input.value = "";
  send.disabled = true;

  try{
    const resp = await fetch(WORKER_URL + "/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: text })
    });

    const raw = await resp.text();
    let data = {};
    try{ data = JSON.parse(raw); }catch{}

    if(!resp.ok){
      addMsg(`HTTP ${resp.status}: ${raw || "error"}`, "err");
    }else if(data && data.ok){
      addMsg(data.answer || "Нет ответа", "bot");
    }else{
      addMsg(raw || "Неожиданный ответ", "err");
    }
  }catch(e){
    addMsg("Ошибка сети: " + (e?.message || e), "err");
  }

  send.disabled = false;
}

/** ===========================
 *  EVENTS
 *  =========================== */
backBtn.addEventListener("click", goBack);
newPuchokBtn.addEventListener("click", createPuchok);

editPuchokBtn.addEventListener("click", () => {
  closeAddMenu();
  renameCurrentPuchok();
});

addMenuBtn.addEventListener("click", (e)=>{
  e.stopPropagation();
  toggleAddMenu();
});

menuAddText.addEventListener("click", ()=>{
  closeAddMenu();
  addTextItemToCurrent("");
});

menuAddFile.addEventListener("click", ()=>{
  closeAddMenu();
  if(!currentPuchokId){ alert("Сначала открой пучок."); return; }
  filePicker.value = "";
  filePicker.click();
});

menuAddAudio.addEventListener("click", async ()=>{
  closeAddMenu();
  if(!currentPuchokId){ alert("Сначала открой пучок."); return; }
  await createAudioItemAndRecord();
});

menuDeletePuchok.addEventListener("click", async ()=>{
  await deleteCurrentPuchok();
});

filePicker.addEventListener("change", async () => {
  const f = filePicker.files && filePicker.files[0];
  if(!f) return;
  await addFileItemToCurrent(f);
});

send.addEventListener("click", handleSend);
input.addEventListener("keydown", (e) => { if(e.key === "Enter") handleSend(); });
clearChatBtn.addEventListener("click", clearChat);

modalClose.addEventListener("click", closeModal);
modalWrap.addEventListener("click", (e)=>{ if(e.target === modalWrap) closeModal(); });
modalSave.addEventListener("click", saveModal);
modalDelete.addEventListener("click", deleteModal);

// close menus when clicking outside
document.addEventListener("click", ()=> closeAddMenu());
addMenu.addEventListener("click", (e)=> e.stopPropagation());

/** ===========================
 *  INIT
 *  =========================== */
(function init(){
  render();
  clearChat();
})();
</script>
</body>
</html>
