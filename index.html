<!-- ✅ ПАТЧ: “умный плеер” для сегментов (единый таймлайн + корректный seek + авто-переход)
ВСТАВЬ/ЗАМЕНИ по месту в твоём исходнике. Я даю точечные куски.

1) ДОБАВЬ CSS (в <style> в конец, перед @media или после — не важно)
-->
<style>
/* --- Smart Audio UI --- */
.audioUI{
  margin-top:12px;
  padding:12px;
  border:1px solid var(--border);
  border-radius:14px;
  background:#fff;
}
.audioTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.audioBtns{
  display:flex;
  gap:8px;
  align-items:center;
}
.audioTime{
  font-variant-numeric: tabular-nums;
  font-size:13px;
  color:var(--muted);
  font-weight:900;
  white-space:nowrap;
}
.audioRange{
  width:100%;
  margin-top:10px;
}
.audioRange input[type="range"]{
  width:100%;
}
.audioMetaLine{
  margin-top:8px;
  font-size:12px;
  color:var(--muted);
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
</style>

<script>
/* =========================================================
   2) ДОБАВЬ хелперы (в JS, рядом с fmtBytes / fmtDate)
   ========================================================= */
function fmtTime(sec){
  const s = Math.max(0, Number(sec || 0));
  const m = Math.floor(s / 60);
  const r = Math.floor(s % 60);
  const hh = Math.floor(m / 60);
  const mm = m % 60;
  if(hh > 0) return `${hh}:${String(mm).padStart(2,"0")}:${String(r).padStart(2,"0")}`;
  return `${mm}:${String(r).padStart(2,"0")}`;
}

async function getBlobDuration(blob){
  // Быстрый способ получить duration через hidden <audio>
  return new Promise((resolve)=>{
    try{
      const url = URL.createObjectURL(blob);
      const a = document.createElement("audio");
      a.preload = "metadata";
      a.src = url;
      a.onloadedmetadata = () => {
        const d = Number(a.duration);
        URL.revokeObjectURL(url);
        resolve(Number.isFinite(d) ? d : 0);
      };
      a.onerror = () => {
        URL.revokeObjectURL(url);
        resolve(0);
      };
    }catch{
      resolve(0);
    }
  });
}

/* =========================================================
   3) ДОБАВЬ state для умного плеера (рядом с audio state)
   ========================================================= */
let smartPlayer = null;
// smartPlayer = { audioEl, segUrls:[], pId,itemId, segIndex, cumulative:[], totalDur, raf }

/* =========================================================
   4) ОБНОВИ appendAudioSegmentFromBlob()
   (замени полностью твою функцию appendAudioSegmentFromBlob на эту)
   ========================================================= */
async function appendAudioSegmentFromBlob(pId, itemId, blob, fileName){
  const p = getPuchok(pId);
  const it = getItem(pId, itemId);
  if(!p || !it || it.type !== "audio") return;

  if(!blob || !blob.size){
    await renderAudioViewer(it, pId);
    return;
  }

  // ⬇️ вычисляем duration сегмента (важно для общего таймлайна)
  const dur = await getBlobDuration(blob);

  const segKey = `blob:${it.id}:seg:${uid()}`;
  await idbPutBlob(segKey, blob);

  it.segments = it.segments || [];
  it.segments.push({
    key: segKey,
    mime: blob.type || "audio/webm",
    size: blob.size || 0,
    createdAt: nowISO(),
    name: fileName || null,
    duration: dur || 0
  });

  it.updatedAt = nowISO();
  p.updatedAt = nowISO();
  saveDB();

  await renderAudioViewer(it, pId);
  render();
}

/* =========================================================
   5) ДОБАВЬ cleanup smart player в closeModal()
   (внутри твоего closeModal() ДО modalWrap.style.display="none" добавь вызов)
   ========================================================= */
function cleanupSmartPlayer(){
  try{
    if(smartPlayer){
      if(smartPlayer.raf) cancelAnimationFrame(smartPlayer.raf);
      if(smartPlayer.audioEl){
        try{ smartPlayer.audioEl.pause(); }catch{}
        smartPlayer.audioEl.src = "";
      }
      if(Array.isArray(smartPlayer.segUrls)){
        for(const u of smartPlayer.segUrls){
          try{ URL.revokeObjectURL(u); }catch{}
        }
      }
    }
  }catch{}
  smartPlayer = null;
}

// В твоём closeModal() добавь первой строкой:
/// cleanupSmartPlayer();


/* =========================================================
   6) ЗАМЕНИ renderAudioViewer() на “умный плеер”
   (замени полностью твою renderAudioViewer на эту)
   ========================================================= */
async function renderAudioViewer(it, pId){
  if(!it || it.type !== "audio") return;

  cleanupSmartPlayer(); // чтобы не было утечек при перерисовках

  const segs = it.segments || [];
  const totalBytes = segs.reduce((s,x)=> s + (x.size || 0), 0);

  // Если duration у каких-то сегментов 0 (старые записи) — дозаполним лениво
  // (важно: делаем это ДО UI, чтобы таймлайн был правильным)
  let needSave = false;
  for(const s of segs){
    if(!s.duration || s.duration <= 0){
      const b = await idbGetBlob(s.key);
      if(b){
        const d = await getBlobDuration(b);
        if(d > 0){
          s.duration = d;
          needSave = true;
        }
      }
    }
  }
  if(needSave){
    it.updatedAt = nowISO();
    const p = getPuchok(pId);
    if(p) p.updatedAt = nowISO();
    saveDB();
  }

  const totalDur = segs.reduce((s,x)=> s + (Number(x.duration)||0), 0);

  const isThisRec = (AUDIO_MODE === "mediarecorder")
    ? (isRecording && currentAudioAppendTarget && currentAudioAppendTarget.itemId === it.id)
    : false;

  const recUI = isThisRec
    ? `<div class="recBadge"><span class="dot"></span>Запись…</div>`
    : (AUDIO_MODE === "capture" ? `<div class="hint">iOS: “Записать” откроет системную запись (capture).</div>` : "");

  const btnLabel = (AUDIO_MODE === "mediarecorder")
    ? (isThisRec ? "Стоп" : (segs.length ? "Дозаписать" : "Записать"))
    : (segs.length ? "Дозаписать" : "Записать");

  modalViewer.innerHTML = `
    <div class="fileRow">
      <div class="fileMeta">
        <div class="fileName">${escapeHTML(it.title || "Аудио")}</div>
        <div class="fileSub">Сегментов: ${segs.length} • ${fmtBytes(totalBytes)}</div>
      </div>
      <div class="tagText tagAudio">Аудио</div>
    </div>

    <div class="audioUI">
      <div class="audioTop">
        <div class="audioBtns">
          <button class="btnOk" id="btnPlayPause" ${segs.length ? "" : "disabled"}>▶︎</button>
          <button class="btnOk" id="btnRec">${btnLabel}</button>
        </div>
        <div class="audioTime" id="audioTime">${fmtTime(0)} / ${fmtTime(totalDur)}</div>
      </div>

      <div class="audioRange">
        <input id="audioSeek" type="range" min="0" max="${Math.max(0, totalDur)}" step="0.01" value="0" ${segs.length ? "" : "disabled"} />
      </div>

      <div class="audioMetaLine">
        <span>Длина: <b>${fmtTime(totalDur)}</b></span>
        <span>Режим: <b>${AUDIO_MODE}</b></span>
      </div>
    </div>

    <div class="viewerActions">
      <button class="btnGhost" id="btnDownload" ${segs.length ? "" : "disabled"}>Скачать</button>
    </div>

    <div style="margin-top:10px;">${recUI}</div>

    <div class="hint" style="margin-top:10px;">
      Это “умный” общий плеер: один таймлайн на все сегменты, можно мотать в любое место — он сам перекинет на нужный сегмент.
    </div>
  `;

  // --- подготовим сегментные URL + cumulative
  const segUrls = [];
  const cumulative = []; // start time каждого сегмента
  let acc = 0;

  for(const s of segs){
    cumulative.push(acc);
    const b = await idbGetBlob(s.key);
    if(b){
      segUrls.push(URL.createObjectURL(b));
    }else{
      segUrls.push(""); // на всякий случай
    }
    acc += (Number(s.duration)||0);
  }

  // --- создаём скрытый audio-движок (без controls)
  const audioEl = document.createElement("audio");
  audioEl.preload = "auto";

  smartPlayer = {
    audioEl,
    segUrls,
    pId,
    itemId: it.id,
    segIndex: 0,
    cumulative,
    totalDur,
    raf: null
  };

  function findSegByGlobalTime(t){
    const T = Math.max(0, Math.min(smartPlayer.totalDur, Number(t||0)));
    // простой поиск (сегментов мало — нормально)
    let idx = 0;
    for(let i=0;i<smartPlayer.cumulative.length;i++){
      const start = smartPlayer.cumulative[i];
      const end = start + (Number(segs[i]?.duration)||0);
      if(T >= start && (T < end || i === smartPlayer.cumulative.length-1)){
        idx = i;
        break;
      }
    }
    const local = T - smartPlayer.cumulative[idx];
    return { idx, local, global: T };
  }

  async function switchTo(idx, localTime, autoplay){
    idx = Math.max(0, Math.min(idx, segs.length-1));
    smartPlayer.segIndex = idx;

    const url = smartPlayer.segUrls[idx];
    if(!url){
      // сегмент не найден — стоп
      try{ smartPlayer.audioEl.pause(); }catch{}
      return;
    }

    const wasPlaying = !smartPlayer.audioEl.paused;
    // смена src сбрасывает currentTime
    smartPlayer.audioEl.src = url;

    // iOS/Safari иногда требует подождать canplay
    await new Promise((resolve)=>{
      const a = smartPlayer.audioEl;
      const done = ()=>{ a.removeEventListener("canplay", done); resolve(); };
      a.addEventListener("canplay", done, { once:true });
      // если canplay не прилетит — всё равно продолжим (fallback)
      setTimeout(()=>{ try{ a.removeEventListener("canplay", done); }catch{} resolve(); }, 400);
      a.load();
    });

    try{
      smartPlayer.audioEl.currentTime = Math.max(0, Number(localTime||0));
    }catch{}

    if(autoplay || wasPlaying){
      try{ await smartPlayer.audioEl.play(); }catch{}
    }
  }

  function updateUI(){
    if(!smartPlayer) return;
    const seek = document.getElementById("audioSeek");
    const timeEl = document.getElementById("audioTime");
    const btnPP = document.getElementById("btnPlayPause");
    if(!seek || !timeEl || !btnPP) return;

    const idx = smartPlayer.segIndex;
    const g = smartPlayer.cumulative[idx] + (smartPlayer.audioEl.currentTime || 0);
    const clamped = Math.max(0, Math.min(smartPlayer.totalDur, g));

    // не дёргаем ползунок, пока пользователь тащит
    if(!seek.__dragging){
      seek.value = String(clamped);
    }

    timeEl.textContent = `${fmtTime(clamped)} / ${fmtTime(smartPlayer.totalDur)}`;
    btnPP.textContent = smartPlayer.audioEl.paused ? "▶︎" : "⏸";
  }

  function startRAF(){
    if(!smartPlayer) return;
    const loop = ()=>{
      if(!smartPlayer) return;
      updateUI();
      smartPlayer.raf = requestAnimationFrame(loop);
    };
    if(smartPlayer.raf) cancelAnimationFrame(smartPlayer.raf);
    smartPlayer.raf = requestAnimationFrame(loop);
  }

  // авто-переход на следующий сегмент
  audioEl.addEventListener("ended", async ()=>{
    if(!smartPlayer) return;
    const next = smartPlayer.segIndex + 1;
    if(next < segs.length){
      await switchTo(next, 0, true);
    }else{
      // конец всего аудио
      updateUI();
    }
  });

  // если во время играет — апдейтим
  audioEl.addEventListener("timeupdate", updateUI);
  audioEl.addEventListener("play", updateUI);
  audioEl.addEventListener("pause", updateUI);

  // стартуем с первого сегмента
  if(segs.length){
    await switchTo(0, 0, false);
  }
  startRAF();
  updateUI();

  // --- UI events
  document.getElementById("btnPlayPause").onclick = async ()=>{
    if(!smartPlayer || !segs.length) return;
    try{
      if(smartPlayer.audioEl.paused){
        await smartPlayer.audioEl.play();
      }else{
        smartPlayer.audioEl.pause();
      }
    }catch{}
    updateUI();
  };

  const seekEl = document.getElementById("audioSeek");
  seekEl.onpointerdown = ()=> { seekEl.__dragging = true; };
  seekEl.onpointerup   = async ()=> {
    seekEl.__dragging = false;
    const t = Number(seekEl.value||0);
    const pos = findSegByGlobalTime(t);
    await switchTo(pos.idx, pos.local, !smartPlayer.audioEl.paused);
    updateUI();
  };
  seekEl.oninput = ()=>{
    // показываем время во время перетаскивания
    const t = Number(seekEl.value||0);
    const timeEl = document.getElementById("audioTime");
    if(timeEl) timeEl.textContent = `${fmtTime(t)} / ${fmtTime(smartPlayer.totalDur)}`;
  };

  // Record / append
  document.getElementById("btnRec").onclick = async ()=>{
    if(AUDIO_MODE === "mediarecorder"){
      if(isThisRec) stopAnyRecordingSafely();
      else await startRecordingToAudioItem(pId, it.id);
    }else{
      pendingAudioTarget = { pId, itemId: it.id };
      audioPicker.value = "";
      audioPicker.click();
    }
  };

  // Download (как у тебя было: “склеить” blob’ами)
  document.getElementById("btnDownload").onclick = async ()=>{
    if(!segs.length) return;
    const merged = await buildAudioBlobFromSegments(it);
    if(!merged) return;
    const url = URL.createObjectURL(merged);
    const a = document.createElement("a");
    a.href = url;
    a.download = (it.title || "audio") + (merged.type.includes("mp4") ? ".m4a" : ".webm");
    a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch{} }, 4000);
  };
}

/* =========================================================
   7) ВАЖНО: в closeModal() добавь cleanupSmartPlayer()
   Пример (твоя функция, только первая строка новая):
   =========================================================
function closeModal(){
  cleanupSmartPlayer();
  stopAnyRecordingSafely();
  ...
}
========================================================= */
</script>
