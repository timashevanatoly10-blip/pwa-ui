<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ТИМ</title>

  <!-- PWA -->
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#f5f6f8">

  <!-- iOS standalone -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="ТИМ">

  <!-- Icons -->
  <link rel="icon" href="/icon-192.png">
  <link rel="apple-touch-icon" href="/icon-192.png">

  <style>
    :root{
      --bg:#f5f6f8;
      --panel:#ffffff;
      --border:#d8dbe0;

      --text:#111317;
      --muted:#667085;

      --btn:#2d6cff;
      --btnText:#fff;

      --inputBg:#f1f3f5;

      --ok:#2f7d32;
      --danger:#b3261e;

      --chip:#f7f7f9;
      --chipBd:#e3e6eb;

      --shadow: 0 10px 30px rgba(16,24,40,.18);

      --msgMeBg:#e8f0ff;
      --msgMeBd:#cfe0ff;
      --msgBotBg:#f6f7f9;
      --msgBotBd:#e3e6eb;

      --hover:#f0f2f5;

      --rangeTrack:#d0d5dd;
      --rangeFill:#2d6cff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Arial,sans-serif;
      background:var(--bg); color:var(--text);
      display:block;
    }

    .safeTop{ padding-top: env(safe-area-inset-top); }
    .safeBottom{ padding-bottom: env(safe-area-inset-bottom); }

    .container{
      width:100%;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      padding:12px;
      gap:12px;
    }

    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      gap:10px;
      box-shadow: var(--shadow);
    }

    .leftHead{display:flex; align-items:center; gap:10px; min-width:0}
    .title{font-weight:800; font-size:16px; white-space:nowrap}
    .crumb{font-size:12px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:56vw}

    .actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:nowrap;
      justify-content:flex-end;
      position:relative;
    }

    button{
      padding:10px 12px;
      border-radius:12px;
      border:none;
      background:var(--btn);
      color:var(--btnText);
      font-weight:800;
      cursor:pointer;
    }
    button:disabled{opacity:.6; cursor:not-allowed}
    .btnGhost{
      background:transparent;
      border:1px solid var(--border);
      color:var(--text);
      font-weight:800;
    }
    .btnDanger{
      background:transparent;
      border:1px solid rgba(179,38,30,.45);
      color:var(--danger);
      font-weight:800;
    }
    .btnOk{
      background:transparent;
      border:1px solid rgba(47,125,50,.45);
      color:var(--ok);
      font-weight:800;
    }

    .iconBtn{
      width:42px;
      height:42px;
      padding:0;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .iconBtn svg{ width:20px; height:20px; display:block; }
    .iconBtnGhost{
      background:transparent;
      border:1px solid var(--border);
      color:var(--text);
    }
    .iconBtnPrimary{
      background:var(--btn);
      border:1px solid rgba(45,108,255,.25);
      box-shadow: 0 8px 18px rgba(45,108,255,.18);
    }
    .iconBtnPrimary svg path{ stroke:#fff; }

    .menu{
      position:absolute;
      top:48px;
      right:0;
      width:220px;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:none;
      z-index:50;
    }
    .menu button{
      width:100%;
      border:0;
      border-radius:0;
      background:transparent;
      color:var(--text);
      padding:12px 12px;
      font-weight:900;
      text-align:left;
      cursor:pointer;
    }
    .menu button:hover{ background:var(--hover); }
    .menu .sep{
      height:1px;
      background:var(--border);
      margin:0;
    }
    .menu .dangerItem{ color:var(--danger); }

    .panel{
      flex:1;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      overflow:auto;
      position:relative;
      box-shadow: var(--shadow);
      min-height: 0;
    }

    .list{display:flex; flex-direction:column; gap:10px}
    .card{
      background:var(--chip);
      border:1px solid var(--chipBd);
      border-radius:14px;
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .card .meta{min-width:0}
    .card .name{
      font-weight:900;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:70vw;
    }
    .card .sub{
      font-size:12px; color:var(--muted); margin-top:4px;
      display:flex; gap:10px; flex-wrap:wrap;
    }
    .pill{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--chipBd);
      color:var(--muted);
      background:#fff;
    }
    .empty{
      color:var(--muted);
      padding:18px;
      border:1px dashed var(--border);
      border-radius:14px;
      text-align:center;
      line-height:1.4;
      background:#fff;
    }

    .itemRow{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      background:#fff;
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
    }
    .itemRow:hover{background:var(--hover)}
    .itemLeft{min-width:0; display:flex; gap:10px; align-items:center}
    .thumb{
      width:44px; height:44px; border-radius:12px;
      border:1px solid var(--border);
      background:#f3f4f6;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
      flex:0 0 auto;
    }
    .thumb img{width:100%; height:100%; object-fit:cover; display:block}
    .thumb .ico{ width:22px; height:22px; opacity:.75; }
    .itemText{min-width:0}
    .itemTitle{
      font-weight:900;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:62vw;
    }
    .itemDesc{
      margin-top:4px;
      font-size:12px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:72vw;
    }
    .tagText{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #cfe0ff;
      color:#1f4fd6;
      background:#e8f0ff;
      white-space:nowrap;
      font-weight:800;
    }
    .tagFile{ border-color:#f4d6a6; color:#9a5a00; background:#fff4e1; }
    .tagImg{ border-color:#c8f1d2; color:#176c2c; background:#e9f9ee; }
    .tagAudio{ border-color:#f3c7d0; color:#8a1830; background:#fdecef; }

    /* Chat dock (collapsible like Notion) */
    .dock{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      box-shadow: var(--shadow);
      min-height: 0;
      transition: max-height .18s ease;
    }
    .dockHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      gap:10px;
    }
    .dockTitle{font-weight:900}
    .dockSmall{
      font-size:12px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:60vw
    }
    .dockBody{
      overflow:auto;
      padding:12px;
      max-height:38vh;
      transition: max-height .18s ease, opacity .18s ease;
    }

    .composer{
      display:flex; gap:10px;
      padding:12px;
      border-top:1px solid var(--border);
      background:#fafbfc;
      align-items:center;
    }
    input{
      width:100%;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--inputBg);
      color:var(--text);
      outline:none;
      font-size:16px;
    }
    .sendBtn{
      width:44px; height:44px;
      padding:0;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
      box-shadow: 0 8px 18px rgba(45,108,255,.22);
    }
    .sendBtn svg{width:20px; height:20px; display:block}

    .dock.collapsed .dockHead{ display:none; }
    .dock.collapsed .dockBody{
      max-height:0;
      padding:0 12px;
      opacity:0;
      pointer-events:none;
    }
    .dock.collapsed .composer{ border-top:0; }
    .dock.expanded .dockHead{ display:flex; }
    .dock.expanded .dockBody{ opacity:1; pointer-events:auto; }

    .collapseBar{
      display:none;
      height:18px;
      align-items:center;
      justify-content:center;
      background:#fafbfc;
      border-top:1px solid var(--border);
      cursor:pointer;
      user-select:none;
    }
    .collapsePill{
      width:44px;
      height:5px;
      border-radius:999px;
      background:#d0d5dd;
    }
    .dock.expanded .collapseBar{ display:flex; }

    .msg{
      padding:10px 12px;
      border-radius:14px;
      margin:10px 0;
      max-width:92%;
      line-height:1.35;
      white-space:pre-wrap;
      word-wrap:break-word;
      border:1px solid transparent;
      position:relative;
      background:#fff;
    }
    .me{margin-left:auto; background:var(--msgMeBg); border-color:var(--msgMeBd)}
    .bot{margin-right:auto; background:var(--msgBotBg); border-color:var(--msgBotBd)}
    .err{margin-right:auto; background:#fff1f1; border-color:#ffd0d0; color:#7a0b0b}
    .msgTools{
      margin-top:8px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .miniBtn{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      font-weight:900;
      cursor:pointer;
      font-size:13px;
    }
    .miniBtnOk{border-color:rgba(47,125,50,.35); color:var(--ok)}
    .miniBtnDanger{border-color:rgba(179,38,30,.35); color:var(--danger)}

    .modalWrap{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    .modal{
      width:min(860px, 100%);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .modalHead{
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--border);
    }
    .modalTitle{
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:68vw;
    }
    .modalBody{padding:12px}
    textarea{
      width:100%;
      min-height:46vh;
      resize:vertical;
      padding:12px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--inputBg);
      color:var(--text);
      outline:none;
      font-size:15px;
      line-height:1.4;
      display:none;
    }
    .viewer{
      display:none;
      width:100%;
      min-height:46vh;
      border-radius:14px;
      border:1px solid var(--border);
      background:#fff;
      overflow:auto;
      padding:12px;
    }
    .viewer img{
      max-width:100%;
      height:auto;
      border-radius:12px;
      border:1px solid var(--border);
      display:block;
      margin:0 auto;
    }
    .viewer .fileRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      border:1px solid var(--border);
      border-radius:14px;
      background:#fff;
    }
    .viewer .fileMeta{min-width:0}
    .viewer .fileName{
      font-weight:900;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width:62vw;
    }
    .viewer .fileSub{font-size:12px; color:var(--muted); margin-top:4px}
    .viewer .viewerActions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; margin-top:10px}

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      justify-content:flex-end;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
      line-height:1.35;
    }
    .recBadge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:900;
      color:#7a0b0b;
      background:#fff1f1;
      border:1px solid #ffd0d0;
      padding:8px 10px;
      border-radius:999px;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;background:#e11d48;
      box-shadow: 0 0 0 4px rgba(225,29,72,.15);
    }
    .recLine{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .recTimePill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      font-weight:900;
      white-space:nowrap;
    }

    /* Smart audio UI */
    .audioBar{
      margin-top:12px;
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      background:#fafbfc;
    }
    .audioTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .audioBtns{display:flex; gap:8px; flex-wrap:wrap}
    .audioBtn{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      font-weight:900;
      cursor:pointer;
    }
    .audioBtnPrimary{
      border-color: rgba(45,108,255,.35);
      color:#1f4fd6;
      background:#e8f0ff;
    }
    .audioTime{
      font-size:12px;
      color:var(--muted);
      font-weight:900;
      white-space:nowrap;
    }
    .audioSliderWrap{
      margin-top:10px;
      display:flex;
      gap:10px;
      align-items:center;
    }

    /* Custom range visuals (fix "not from zero" + fill mismatch) */
    .audioSlider{
      width:100%;
      -webkit-appearance:none;
      appearance:none;
      height:26px;
      background:transparent;
      outline:none;
    }
    .audioSlider::-webkit-slider-runnable-track{
      height:8px;
      border-radius:999px;
      background:
        linear-gradient(var(--rangeFill), var(--rangeFill)) 0 50% / var(--fill, 0%) 8px no-repeat,
        linear-gradient(var(--rangeTrack), var(--rangeTrack)) 0 50% / 100% 8px no-repeat;
      border:1px solid rgba(0,0,0,0.02);
    }
    .audioSlider::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      border-radius:999px;
      background:#fff;
      border:1px solid rgba(17,19,23,.2);
      margin-top:-6px;
      box-shadow: 0 6px 14px rgba(16,24,40,.18);
    }
    .audioSlider::-moz-range-track{
      height:8px;
      border-radius:999px;
      background:var(--rangeTrack);
    }
    .audioSlider::-moz-range-progress{
      height:8px;
      border-radius:999px;
      background:var(--rangeFill);
    }
    .audioSlider::-moz-range-thumb{
      width:18px;height:18px;border-radius:999px;
      background:#fff;border:1px solid rgba(17,19,23,.2);
      box-shadow: 0 6px 14px rgba(16,24,40,.18);
    }

    /* Edge-to-edge on phone */
    @media (max-width: 520px){
      .container{ padding:0; gap:0; }
      header, .panel, .dock{
        border-radius:0;
        border-left:0;
        border-right:0;
      }
      header{ box-shadow:none; }
      .panel{ box-shadow:none; }
      .dock{ box-shadow:none; }
      header{ padding:12px 12px; }
      .panel{ padding:12px 12px; }
      .dockHead{ padding:10px 12px; }
      .composer{ padding:12px 12px; }
    }

    @media (min-width: 900px){
      .container{ padding:16px 18px; }
    }
  </style>
</head>

<body>
  <div class="container safeTop safeBottom">
    <header>
      <div class="leftHead">
        <button id="backBtn" class="btnGhost" style="display:none;">←</button>
        <div>
          <div class="title" id="headTitle">ТИМ</div>
          <div class="crumb" id="headCrumb">Пучки + чат</div>
        </div>
      </div>

      <div class="actions" id="headActions">
        <button id="newPuchokBtn">+ Пучок</button>

        <button id="editPuchokBtn" class="iconBtn iconBtnGhost" style="display:none;" title="Переименовать">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M4 20h4l10.5-10.5a2 2 0 0 0 0-3L16.5 4.5a2 2 0 0 0-3 0L3 15v5Z" stroke="#111317" stroke-width="2" stroke-linejoin="round"/>
            <path d="M13.5 6.5l4 4" stroke="#111317" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>

        <button id="addMenuBtn" class="iconBtn iconBtnPrimary" style="display:none;" title="Добавить">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M12 5v14M5 12h14" stroke="white" stroke-width="2.4" stroke-linecap="round"/>
          </svg>
        </button>

        <div id="addMenu" class="menu" role="menu" aria-hidden="true">
          <button id="menuAddText">Добавить текст</button>
          <button id="menuAddFile">Добавить файл/фото</button>
          <button id="menuAddAudio">Добавить аудио</button>
          <div class="sep"></div>
          <button id="menuDeletePuchok" class="dangerItem">Удалить пучок</button>
        </div>
      </div>
    </header>

    <div class="panel" id="mainPanel"></div>

    <div class="dock collapsed" id="chatDock">
      <div class="dockHead">
        <div>
          <div class="dockTitle">Чат</div>
          <div class="dockSmall" id="chatHint">Пишешь — отправляю в Worker (/chat). Ответ можно сохранить “В пучок”.</div>
        </div>
        <button id="clearChatBtn" class="btnGhost">Очистить</button>
      </div>

      <div class="dockBody" id="chat"></div>

      <div class="collapseBar" id="collapseBar" title="Свернуть чат">
        <div class="collapsePill"></div>
      </div>

      <div class="composer">
        <input id="input" type="text" placeholder="Напиши сообщение..." autocomplete="off" />
        <button id="send" class="sendBtn" title="Отправить">
          <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <path d="M4.5 12L19 5.5L13 19L11.8 13.7L4.5 12Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- One picker for everything -->
  <input id="filePicker" type="file" style="display:none" />
  <!-- Audio fallback (iOS / no MediaRecorder) -->
  <input id="audioPicker" type="file" accept="audio/*,video/*" capture="microphone" style="display:none" />

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Элемент</div>
        <div class="actions">
          <button id="modalClose" class="btnGhost">Закрыть</button>
        </div>
      </div>
      <div class="modalBody">
        <textarea id="modalTextarea" spellcheck="false"></textarea>
        <div class="viewer" id="modalViewer"></div>

        <div class="row" id="modalRow">
          <button id="modalDelete" class="btnDanger">Удалить</button>
          <button id="modalSave" class="btnOk">Сохранить</button>
        </div>

        <div class="hint" id="modalHint">—</div>
      </div>
    </div>
  </div>

<script>
/** ===========================
 *  CONFIG
 *  =========================== */
const WORKER_URL = "https://gptim24.timashevanatoly10.workers.dev";
const STORAGE_KEY = "tim_puchki_v2";

// IndexedDB for blobs
const IDB_NAME = "tim_puchki_blobs";
const IDB_STORE = "blobs";

/** ===========================
 *  DOM
 *  =========================== */
const mainPanel = document.getElementById("mainPanel");
const backBtn = document.getElementById("backBtn");
const headTitle = document.getElementById("headTitle");
const headCrumb = document.getElementById("headCrumb");

const newPuchokBtn = document.getElementById("newPuchokBtn");

const editPuchokBtn = document.getElementById("editPuchokBtn");
const addMenuBtn = document.getElementById("addMenuBtn");
const addMenu = document.getElementById("addMenu");
const menuAddText = document.getElementById("menuAddText");
const menuAddFile = document.getElementById("menuAddFile");
const menuAddAudio = document.getElementById("menuAddAudio");
const menuDeletePuchok = document.getElementById("menuDeletePuchok");

const chatDock = document.getElementById("chatDock");
const collapseBar = document.getElementById("collapseBar");
const chat = document.getElementById("chat");
const input = document.getElementById("input");
const send = document.getElementById("send");
const clearChatBtn = document.getElementById("clearChatBtn");
const chatHint = document.getElementById("chatHint");

const filePicker = document.getElementById("filePicker");
const audioPicker = document.getElementById("audioPicker");

const modalWrap = document.getElementById("modalWrap");
const modalTitle = document.getElementById("modalTitle");
const modalTextarea = document.getElementById("modalTextarea");
const modalViewer = document.getElementById("modalViewer");
const modalClose = document.getElementById("modalClose");
const modalSave = document.getElementById("modalSave");
const modalDelete = document.getElementById("modalDelete");
const modalHint = document.getElementById("modalHint");

/** ===========================
 *  STATE
 *  =========================== */
let db = loadDB();
let currentPuchokId = null;
let openItemId = null;
let openItemType = null;

// Recording state
let mediaRecorder = null;
let recChunks = [];
let isRecording = false;
let currentAudioAppendTarget = null; // { pId, itemId }
let pendingAudioTarget = null;       // for capture fallback

// Recording UI clock (LIVE while recording)
let recClockRaf = null;
let recClockStartPerf = 0;
let recClockBaseSec = 0;
let recClockItemId = null;

// Smart audio player state (per opened audio item)
let audioCtx = null;
let activeSource = null;
let activePlayingItemId = null;
let playStartCtxTime = 0;
let playStartOffset = 0;
let currentOffset = 0;
let rafId = null;

// Cache decoded/merged buffers + wav blobs per item
const audioCache = {}; // { [itemId]: { sig, buffer, duration, wavBlob } }

/** ===========================
 *  PLATFORM / FEATURE DETECT
 *  =========================== */
function isIOS(){
  const ua = navigator.userAgent || "";
  return /iPad|iPhone|iPod/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
}
function hasMediaRecorder(){
  return typeof MediaRecorder !== "undefined" && typeof MediaRecorder === "function";
}
function canUseWebAudio(){
  return typeof (window.AudioContext || window.webkitAudioContext) !== "undefined";
}
function chooseAudioMode(){
  return hasMediaRecorder() ? "mediarecorder" : "capture";
}
let AUDIO_MODE = chooseAudioMode();

/** ===========================
 *  IndexedDB helpers
 *  =========================== */
function idbOpen(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(IDB_NAME, 1);
    req.onupgradeneeded = () => {
      const d = req.result;
      if(!d.objectStoreNames.contains(IDB_STORE)){
        d.createObjectStore(IDB_STORE, { keyPath: "key" });
      }
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbPutBlob(key, blob){
  const d = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = d.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).put({ key, blob });
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error);
  });
}
async function idbGetBlob(key){
  const d = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = d.transaction(IDB_STORE, "readonly");
    const req = tx.objectStore(IDB_STORE).get(key);
    req.onsuccess = ()=> resolve(req.result ? req.result.blob : null);
    req.onerror = ()=> reject(req.error);
  });
}
async function idbDelete(key){
  const d = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = d.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).delete(key);
    tx.oncomplete = ()=> resolve(true);
    tx.onerror = ()=> reject(tx.error);
  });
}

/** ===========================
 *  HELPERS
 *  =========================== */
function nowISO(){ return new Date().toISOString(); }
function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
function safeTitleFromText(t){
  const s = (t || "").toString().trim().replace(/\s+/g," ");
  return s.length > 48 ? s.slice(0, 48) + "…" : (s || "Без названия");
}
function fmtDate(iso){
  try{
    const d = new Date(iso);
    return d.toLocaleString(undefined, { year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit" });
  }catch{ return iso; }
}
function fmtBytes(bytes){
  const b = Number(bytes || 0);
  if(!b) return "0 B";
  const units = ["B","KB","MB","GB"];
  let i = 0; let n = b;
  while(n >= 1024 && i < units.length-1){ n/=1024; i++; }
  return `${n.toFixed(n>=10||i===0?0:1)} ${units[i]}`;
}
function fmtTimeSec(sec){
  sec = Math.max(0, Number(sec || 0));
  const m = Math.floor(sec/60);
  const s = Math.floor(sec%60);
  return `${m}:${s.toString().padStart(2,"0")}`;
}
function icoSVG(kind){
  const common = `class="ico" viewBox="0 0 24 24" fill="none"`;
  if(kind==="file"){
    return `<svg ${common}><path d="M7 3h7l3 3v15H7V3Z" stroke="#111317" stroke-width="2"/><path d="M14 3v6h6" stroke="#111317" stroke-width="2"/></svg>`;
  }
  if(kind==="audio"){
    return `<svg ${common}><path d="M12 3v12" stroke="#111317" stroke-width="2"/><path d="M8 7v8" stroke="#111317" stroke-width="2"/><path d="M16 7v8" stroke="#111317" stroke-width="2"/><path d="M5 11v4" stroke="#111317" stroke-width="2"/><path d="M19 11v4" stroke="#111317" stroke-width="2"/></svg>`;
  }
  return `<svg ${common}><path d="M4 6h16v12H4V6Z" stroke="#111317" stroke-width="2"/><path d="M8 11l2.5 3 2-2 3.5 4" stroke="#111317" stroke-width="2" stroke-linejoin="round"/><path d="M9 9.5h.01" stroke="#111317" stroke-width="3" stroke-linecap="round"/></svg>`;
}
function typeLabel(it){
  if(it.type==="image") return { text:"Фото", cls:"tagText tagImg" };
  if(it.type==="file") return { text:"Файл", cls:"tagText tagFile" };
  if(it.type==="audio") return { text:"Аудио", cls:"tagText tagAudio" };
  return { text:"Текст", cls:"tagText" };
}
function escapeHTML(s){
  return (s||"").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

/** ===========================
 *  RANGE FILL (cross-browser)
 *  =========================== */
function setRangeFill(el){
  if(!el) return;
  const min = Number(el.min || 0);
  const max = Number(el.max || 0);
  const val = Number(el.value || 0);
  const denom = (max - min) || 1;
  const pct = clamp(((val - min) / denom) * 100, 0, 100);
  el.style.setProperty("--fill", pct + "%");
}

/** ===========================
 *  RECORDING LIVE CLOCK
 *  =========================== */
function stopRecClock(){
  if(recClockRaf) cancelAnimationFrame(recClockRaf);
  recClockRaf = null;
  recClockItemId = null;
}
function startRecClock(itemId, baseSec){
  stopRecClock();
  recClockItemId = itemId;
  recClockBaseSec = Number(baseSec || 0);
  recClockStartPerf = performance.now();

  const tick = () => {
    if(!isRecording || !recClockItemId || recClockItemId !== itemId){
      stopRecClock();
      return;
    }
    const live = recClockBaseSec + (performance.now() - recClockStartPerf)/1000;
    const el = document.getElementById("recLiveTime");
    if(el) el.textContent = "Запись: " + fmtTimeSec(live);
    recClockRaf = requestAnimationFrame(tick);
  };
  recClockRaf = requestAnimationFrame(tick);
}

/** ===========================
 *  DB (localStorage metadata)
 *  =========================== */
function loadDB(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return { puchki: [] };
    const parsed = JSON.parse(raw);
    if(!parsed || !Array.isArray(parsed.puchki)) return { puchki: [] };
    parsed.puchki.forEach(p => { if(!Array.isArray(p.items)) p.items = []; });
    return parsed;
  }catch{
    return { puchki: [] };
  }
}
function saveDB(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(db)); }
function getPuchok(id){ return db.puchki.find(p => p.id === id) || null; }
function getItem(pId, itemId){
  const p = getPuchok(pId);
  if(!p) return null;
  return (p.items || []).find(x => x.id === itemId) || null;
}

/** ===========================
 *  MENU (Add)
 *  =========================== */
function closeAddMenu(){
  addMenu.style.display = "none";
  addMenu.setAttribute("aria-hidden","true");
}
function toggleAddMenu(){
  if(addMenu.style.display === "block") closeAddMenu();
  else{
    addMenu.style.display = "block";
    addMenu.setAttribute("aria-hidden","false");
  }
}

/** ===========================
 *  CHAT DOCK COLLAPSE/EXPAND
 *  =========================== */
function expandChat(){
  chatDock.classList.remove("collapsed");
  chatDock.classList.add("expanded");
  setTimeout(()=> { chat.scrollTop = chat.scrollHeight; }, 10);
}
function collapseChat(){
  chatDock.classList.remove("expanded");
  chatDock.classList.add("collapsed");
}
input.addEventListener("focus", expandChat);
collapseBar.addEventListener("click", collapseChat);

/** ===========================
 *  UI HEADER
 *  =========================== */
function setHeaderForList(){
  backBtn.style.display = "none";
  headTitle.textContent = "ТИМ";
  headCrumb.textContent = "Пучки + чат";

  editPuchokBtn.style.display = "none";
  addMenuBtn.style.display = "none";
  closeAddMenu();

  newPuchokBtn.style.display = "";
  chatHint.textContent = "Совет: сначала открой пучок → тогда “В пучок” будет сохранять ответы прямо туда.";
}
function setHeaderForPuchok(p){
  backBtn.style.display = "";
  headTitle.textContent = "Пучок";
  headCrumb.textContent = p.title || "Без названия";

  newPuchokBtn.style.display = "none";
  editPuchokBtn.style.display = "";
  addMenuBtn.style.display = "";
  closeAddMenu();

  chatHint.textContent = "Ты в пучке: ответы бота можно сохранять кнопкой “В пучок”.";
}

/** ===========================
 *  UI RENDER
 *  =========================== */
function render(){
  mainPanel.innerHTML = "";
  if(!currentPuchokId){
    setHeaderForList();
    renderPuchokList();
  }else{
    const p = getPuchok(currentPuchokId);
    if(!p){
      currentPuchokId = null;
      render();
      return;
    }
    setHeaderForPuchok(p);
    renderPuchokInside(p);
  }
}

function renderPuchokList(){
  const wrap = document.createElement("div");
  wrap.className = "list";

  if(db.puchki.length === 0){
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = "Пока нет пучков.<br>Нажми <b>+ Пучок</b>, потом зайди внутрь и сохраняй туда ответы / заметки / файлы / аудио.";
    wrap.appendChild(empty);
  }else{
    const sorted = [...db.puchki].sort((a,b)=> (b.updatedAt||b.createdAt||"").localeCompare(a.updatedAt||a.createdAt||""));
    for(const p of sorted){
      const card = document.createElement("div");
      card.className = "card";

      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = p.title || "Без названия";

      const sub = document.createElement("div");
      sub.className = "sub";
      const count = (p.items || []).length;

      const pill1 = document.createElement("span");
      pill1.className = "pill";
      pill1.textContent = `Элементов: ${count}`;

      const pill2 = document.createElement("span");
      pill2.className = "pill";
      pill2.textContent = `Обновлён: ${fmtDate(p.updatedAt || p.createdAt || nowISO())}`;

      sub.appendChild(pill1);
      sub.appendChild(pill2);

      meta.appendChild(name);
      meta.appendChild(sub);

      const btn = document.createElement("button");
      btn.className = "btnGhost";
      btn.textContent = "Открыть";
      btn.addEventListener("click", () => openPuchok(p.id));

      card.appendChild(meta);
      card.appendChild(btn);
      wrap.appendChild(card);
    }
  }

  mainPanel.appendChild(wrap);
}

function renderPuchokInside(p){
  const wrap = document.createElement("div");
  wrap.className = "list";

  if((p.items || []).length === 0){
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = "Внутри пусто.<br>Нажми <b>+</b> сверху справа → добавь текст / файл / аудио.";
    wrap.appendChild(empty);
  }else{
    const sorted = [...p.items].sort((a,b)=> (b.updatedAt||b.createdAt||"").localeCompare(a.updatedAt||a.createdAt||""));
    for(const it of sorted){
      const row = document.createElement("div");
      row.className = "itemRow";
      row.addEventListener("click", () => openItem(p.id, it.id));

      const left = document.createElement("div");
      left.className = "itemLeft";

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      if(it.type === "image" && it.thumbKey){
        thumb.innerHTML = `<span style="color:#98a2b3;font-size:12px;font-weight:900">…</span>`;
        (async()=>{
          const b = await idbGetBlob(it.thumbKey);
          if(b){
            const url = URL.createObjectURL(b);
            const img = document.createElement("img");
            img.src = url;
            img.onload = ()=> URL.revokeObjectURL(url);
            thumb.innerHTML = "";
            thumb.appendChild(img);
          }else{
            thumb.innerHTML = icoSVG("image");
          }
        })();
      }else{
        thumb.innerHTML = icoSVG(it.type==="file" ? "file" : it.type==="audio" ? "audio" : "image");
      }

      const textWrap = document.createElement("div");
      textWrap.className = "itemText";

      const title = document.createElement("div");
      title.className = "itemTitle";
      title.textContent = it.title || "Элемент";

      const desc = document.createElement("div");
      desc.className = "itemDesc";

      if(it.type === "text"){
        const preview = (it.content || "").toString().trim().replace(/\s+/g," ");
        desc.textContent = preview ? (preview.length > 90 ? preview.slice(0,90)+"…" : preview) : "Пусто";
      }else if(it.type === "image"){
        desc.textContent = `${fmtBytes(it.size)} • ${fmtDate(it.createdAt || it.updatedAt || nowISO())}`;
      }else if(it.type === "file"){
        desc.textContent = `${fmtBytes(it.size)} • ${it.mime || "file"} • ${fmtDate(it.createdAt || it.updatedAt || nowISO())}`;
      }else if(it.type === "audio"){
        const segs = (it.segments || []).length;
        const total = (it.segments || []).reduce((s,x)=> s + (x.size || 0), 0);
        desc.textContent = `Сегментов: ${segs} • ${fmtBytes(total)} • ${fmtDate(it.createdAt || it.updatedAt || nowISO())}`;
      }else{
        desc.textContent = fmtDate(it.createdAt || it.updatedAt || nowISO());
      }

      textWrap.appendChild(title);
      textWrap.appendChild(desc);

      left.appendChild(thumb);
      left.appendChild(textWrap);

      const right = document.createElement("div");
      const t = typeLabel(it);
      right.className = t.cls;
      right.textContent = t.text;

      row.appendChild(left);
      row.appendChild(right);
      wrap.appendChild(row);
    }
  }

  mainPanel.appendChild(wrap);
}

/** ===========================
 *  NAV
 *  =========================== */
function openPuchok(id){
  currentPuchokId = id;
  render();
}
function goBack(){
  closeAddMenu();
  currentPuchokId = null;
  render();
}

/** ===========================
 *  CRUD: Puchok
 *  =========================== */
function createPuchok(){
  const name = prompt("Название пучка:", "Новый пучок");
  if(name === null) return;
  const p = {
    id: uid(),
    title: (name || "").trim() || "Новый пучок",
    createdAt: nowISO(),
    updatedAt: nowISO(),
    items: []
  };
  db.puchki.push(p);
  saveDB();
  openPuchok(p.id);
}
function renameCurrentPuchok(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  const name = prompt("Новое название пучка:", p.title || "");
  if(name === null) return;
  p.title = (name || "").trim() || "Без названия";
  p.updatedAt = nowISO();
  saveDB();
  render();
}
async function deleteCurrentPuchok(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  closeAddMenu();
  const ok = confirm(`Удалить пучок “${p.title || "Без названия"}”?`);
  if(!ok) return;

  for(const it of (p.items || [])){
    await cleanupItemBlobs(it);
  }

  db.puchki = db.puchki.filter(x => x.id !== p.id);
  saveDB();
  currentPuchokId = null;
  render();
}

/** ===========================
 *  CRUD: Items
 *  =========================== */
function addTextItemToCurrent(initialText = ""){
  const p = getPuchok(currentPuchokId);
  if(!p){
    alert("Сначала открой пучок — тогда можно добавлять туда элементы.");
    return;
  }
  const it = {
    id: uid(),
    type: "text",
    title: safeTitleFromText(initialText) || "Текст",
    content: (initialText || "").toString(),
    createdAt: nowISO(),
    updatedAt: nowISO()
  };
  p.items.push(it);
  p.updatedAt = nowISO();
  saveDB();
  render();
  openItem(p.id, it.id);
}

async function addFileItemToCurrent(file){
  const p = getPuchok(currentPuchokId);
  if(!p){
    alert("Сначала открой пучок — тогда можно добавлять туда элементы.");
    return;
  }

  const isImg = (file.type || "").startsWith("image/");
  const id = uid();
  const blobKey = `blob:${id}:main`;
  await idbPutBlob(blobKey, file);

  let it;
  if(isImg){
    const thumbKey = `blob:${id}:thumb`;
    await idbPutBlob(thumbKey, file);
    it = {
      id,
      type: "image",
      title: file.name ? file.name : "Фото",
      blobKey,
      thumbKey,
      mime: file.type || "image/*",
      size: file.size || 0,
      createdAt: nowISO(),
      updatedAt: nowISO()
    };
  }else{
    it = {
      id,
      type: "file",
      title: file.name || "Файл",
      blobKey,
      mime: file.type || "application/octet-stream",
      size: file.size || 0,
      createdAt: nowISO(),
      updatedAt: nowISO()
    };
  }

  p.items.push(it);
  p.updatedAt = nowISO();
  saveDB();
  render();
  openItem(p.id, it.id);
}

async function appendAudioSegmentFromBlob(pId, itemId, blob, fileName){
  const p = getPuchok(pId);
  const it = getItem(pId, itemId);
  if(!p || !it || it.type !== "audio") return;

  if(!blob || !blob.size){
    await renderAudioViewer(it, pId);
    return;
  }

  const segKey = `blob:${it.id}:seg:${uid()}`;
  await idbPutBlob(segKey, blob);

  it.segments = it.segments || [];
  it.segments.push({
    key: segKey,
    mime: blob.type || "application/octet-stream",
    size: blob.size || 0,
    createdAt: nowISO(),
    name: fileName || null
  });

  it.updatedAt = nowISO();
  p.updatedAt = nowISO();
  saveDB();

  // Bust cache for this item
  delete audioCache[it.id];

  await renderAudioViewer(it, pId);
  render();
}

async function createAudioItemAndRecord(){
  const p = getPuchok(currentPuchokId);
  if(!p){
    alert("Сначала открой пучок — тогда можно добавлять туда элементы.");
    return;
  }
  const id = uid();
  const it = {
    id,
    type: "audio",
    title: `Аудио ${new Date().toLocaleDateString()}`,
    segments: [],
    durationSec: 0,
    createdAt: nowISO(),
    updatedAt: nowISO()
  };
  p.items.push(it);
  p.updatedAt = nowISO();
  saveDB();
  render();

  await openItem(p.id, it.id);
  await startRecordingToAudioItem(p.id, it.id);
}

/** ===========================
 *  MODAL / OPEN ITEM
 *  =========================== */
function stopAnyRecordingSafely(){
  try{
    if(mediaRecorder && isRecording){
      try{ mediaRecorder.requestData(); }catch{}
      mediaRecorder.stop();
    }
  }catch{}
}

function stopSmartPlayback(){
  try{
    if(activeSource){
      try{ activeSource.stop(0); }catch{}
    }
  }catch{}
  activeSource = null;
  activePlayingItemId = null;
  if(rafId) cancelAnimationFrame(rafId);
  rafId = null;
}

function closeModal(){
  stopAnyRecordingSafely();
  stopRecClock();
  stopSmartPlayback();
  modalWrap.style.display = "none";
  modalTextarea.style.display = "none";
  modalViewer.style.display = "none";
  modalViewer.innerHTML = "";
  openItemId = null;
  openItemType = null;
}

async function openItem(puchokId, itemId){
  const p = getPuchok(puchokId);
  if(!p) return;
  const it = (p.items || []).find(x => x.id === itemId);
  if(!it) return;

  // stop playback if switching items
  stopSmartPlayback();

  openItemId = itemId;
  openItemType = it.type;

  modalTitle.textContent = it.title || "Элемент";
  modalHint.textContent = "";
  modalViewer.innerHTML = "";

  modalDelete.style.display = "";
  modalSave.style.display = "none";

  if(it.type === "text"){
    modalTextarea.style.display = "block";
    modalViewer.style.display = "none";
    modalTextarea.value = it.content || "";
    modalSave.style.display = "";
    modalHint.textContent = "Текст можно редактировать и сохранять.";
    modalWrap.style.display = "flex";
    setTimeout(()=> modalTextarea.focus(), 50);
    return;
  }

  modalTextarea.style.display = "none";
  modalViewer.style.display = "block";
  modalWrap.style.display = "flex";

  if(it.type === "image"){
    modalHint.textContent = "Фото хранится локально (IndexedDB).";
    const b = await idbGetBlob(it.blobKey);
    if(!b){
      modalViewer.innerHTML = `<div class="empty">Файл не найден в хранилище.</div>`;
      return;
    }
    const url = URL.createObjectURL(b);
    modalViewer.innerHTML = `
      <img src="${url}" alt="Фото" />
      <div class="viewerActions">
        <button class="btnGhost" id="btnOpenNewTab">Открыть</button>
        <button class="btnGhost" id="btnDownload">Скачать</button>
      </div>
    `;
    document.getElementById("btnOpenNewTab").onclick = () => window.open(url, "_blank");
    document.getElementById("btnDownload").onclick = () => {
      const a = document.createElement("a");
      a.href = url;
      a.download = it.title || "image";
      a.click();
    };
    return;
  }

  if(it.type === "file"){
    modalHint.textContent = "Файл хранится локально (IndexedDB).";
    const b = await idbGetBlob(it.blobKey);
    if(!b){
      modalViewer.innerHTML = `<div class="empty">Файл не найден в хранилище.</div>`;
      return;
    }
    const url = URL.createObjectURL(b);
    modalViewer.innerHTML = `
      <div class="fileRow">
        <div class="fileMeta">
          <div class="fileName">${escapeHTML(it.title || "Файл")}</div>
          <div class="fileSub">${escapeHTML(it.mime || "file")} • ${fmtBytes(it.size)}</div>
        </div>
        <div class="tagText tagFile">Файл</div>
      </div>
      <div class="viewerActions">
        <button class="btnGhost" id="btnOpenNewTab">Открыть</button>
        <button class="btnGhost" id="btnDownload">Скачать</button>
      </div>
      <div class="hint">Открытие зависит от типа файла и возможностей браузера. Если не откроется — используй “Скачать”.</div>
    `;
    document.getElementById("btnOpenNewTab").onclick = () => window.open(url, "_blank");
    document.getElementById("btnDownload").onclick = () => {
      const a = document.createElement("a");
      a.href = url;
      a.download = it.title || "file";
      a.click();
    };
    return;
  }

  if(it.type === "audio"){
    const modeTxt = (AUDIO_MODE === "mediarecorder")
      ? "Запись: MediaRecorder (браузер)."
      : "Запись: системная (capture), если браузер не поддерживает MediaRecorder.";
    modalHint.textContent = `${modeTxt} Воспроизведение/таймлайн: умный плеер. Скачивание: WAV (одним файлом).`;
    await renderAudioViewer(it, puchokId);
    return;
  }
}

/** ===========================
 *  MODAL SAVE/DELETE
 *  =========================== */
function saveModal(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  const it = (p.items || []).find(x => x.id === openItemId);
  if(!it || it.type !== "text") return;

  const txt = modalTextarea.value || "";
  it.content = txt;
  it.title = safeTitleFromText(txt) || (it.title || "Текст");
  it.updatedAt = nowISO();
  p.updatedAt = nowISO();
  saveDB();
  closeModal();
  render();
}

async function deleteModal(){
  const p = getPuchok(currentPuchokId);
  if(!p) return;
  const it = (p.items || []).find(x => x.id === openItemId);
  if(!it) return;

  const ok = confirm("Удалить этот элемент?");
  if(!ok) return;

  stopAnyRecordingSafely();
  stopRecClock();
  stopSmartPlayback();
  await cleanupItemBlobs(it);

  p.items = (p.items || []).filter(x => x.id !== it.id);
  p.updatedAt = nowISO();
  saveDB();
  closeModal();
  render();
}

async function cleanupItemBlobs(it){
  try{
    if(it.type === "image"){
      if(it.blobKey) await idbDelete(it.blobKey);
      if(it.thumbKey) await idbDelete(it.thumbKey);
    } else if(it.type === "file"){
      if(it.blobKey) await idbDelete(it.blobKey);
    } else if(it.type === "audio"){
      for(const s of (it.segments || [])){
        if(s && s.key) await idbDelete(s.key);
      }
      delete audioCache[it.id];
    }
  }catch{}
}

/** ===========================
 *  AUDIO: RECORDING
 *  =========================== */
async function ensureMic(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    alert("Запись аудио не поддерживается в этом браузере.");
    return null;
  }
  try{
    return await navigator.mediaDevices.getUserMedia({ audio: true });
  }catch(e){
    alert("Нет доступа к микрофону.");
    return null;
  }
}

function pickBestMime(){
  try{
    if(hasMediaRecorder()){
      const prefer = [];
      if(isIOS()){
        prefer.push("audio/mp4");
        prefer.push("audio/mp4;codecs=mp4a.40.2");
      }
      prefer.push("audio/webm;codecs=opus");
      prefer.push("audio/webm");
      prefer.push("audio/ogg;codecs=opus");
      for(const m of prefer){
        if(MediaRecorder.isTypeSupported(m)) return m;
      }
    }
  }catch{}
  return "";
}

async function startRecordingToAudioItem(pId, itemId){
  const it = getItem(pId, itemId);
  const p = getPuchok(pId);
  if(!it || !p || it.type !== "audio") return;

  if(isRecording){
    stopAnyRecordingSafely();
    return;
  }

  if(AUDIO_MODE === "mediarecorder"){
    // NOTE: iOS is strict: do not add extra awaits between user gesture and recorder.start()
    const stream = await ensureMic();
    if(!stream) return;

    const mime = pickBestMime();
    recChunks = [];
    mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
    isRecording = true;
    currentAudioAppendTarget = { pId, itemId };

    mediaRecorder.ondataavailable = (ev) => {
      if(ev.data && ev.data.size > 0) recChunks.push(ev.data);
    };

    mediaRecorder.onstop = async () => {
      isRecording = false;
      stopRecClock();
      try{ stream.getTracks().forEach(t=>t.stop()); }catch{}

      const target = currentAudioAppendTarget;
      currentAudioAppendTarget = null;

      const chunks = recChunks;
      recChunks = [];

      if(!target) return;
      const blob = new Blob(chunks, { type: (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : "application/octet-stream" });
      await appendAudioSegmentFromBlob(target.pId, target.itemId, blob, null);
    };

    mediaRecorder.start(1000);

    // start LIVE timer immediately (no decoding here)
    const baseSec = Number(it.durationSec || (audioCache[it.id]?.duration) || 0);
    startRecClock(it.id, baseSec);

    // update UI (safe after start)
    renderAudioViewer(it, pId);
    return;
  }

  // capture fallback
  pendingAudioTarget = { pId, itemId };
  audioPicker.value = "";
  audioPicker.click();
}

/** ===========================
 *  AUDIO: SMART PLAYER (WebAudio)
 *  =========================== */
function getAudioSig(it){
  const segs = it.segments || [];
  return segs.map(s => `${s.key}:${s.size || 0}:${s.mime || ""}`).join("|");
}

async function ensureAudioContext(){
  if(!canUseWebAudio()) return null;
  if(!audioCtx){
    const Ctx = window.AudioContext || window.webkitAudioContext;
    audioCtx = new Ctx();
  }
  if(audioCtx.state === "suspended"){
    try{ await audioCtx.resume(); }catch{}
  }
  return audioCtx;
}

async function decodeBlobToAudioBuffer(ctx, blob){
  const ab = await blob.arrayBuffer();
  return await ctx.decodeAudioData(ab.slice(0));
}

function concatAudioBuffers(ctx, buffers){
  if(!buffers || buffers.length === 0) return null;
  const channels = Math.max(...buffers.map(b => b.numberOfChannels));
  const sampleRate = buffers[0].sampleRate;
  const totalLength = buffers.reduce((sum,b)=> sum + b.length, 0);

  const out = ctx.createBuffer(channels, totalLength, sampleRate);
  for(let ch=0; ch<channels; ch++){
    const outData = out.getChannelData(ch);
    let offset = 0;
    for(const b of buffers){
      const src = b.getChannelData(Math.min(ch, b.numberOfChannels-1));
      outData.set(src, offset);
      offset += b.length;
    }
  }
  return out;
}

function audioBufferToWavBlob(buffer){
  const numCh = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const numFrames = buffer.length;

  const interleaved = new Float32Array(numFrames * numCh);
  for(let i=0; i<numFrames; i++){
    for(let ch=0; ch<numCh; ch++){
      interleaved[i*numCh + ch] = buffer.getChannelData(ch)[i];
    }
  }

  const pcm16 = new Int16Array(interleaved.length);
  for(let i=0;i<interleaved.length;i++){
    let s = Math.max(-1, Math.min(1, interleaved[i]));
    pcm16[i] = s < 0 ? (s * 0x8000) : (s * 0x7FFF);
  }

  const bytesPerSample = 2;
  const blockAlign = numCh * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = pcm16.length * bytesPerSample;

  const bufferSize = 44 + dataSize;
  const ab = new ArrayBuffer(bufferSize);
  const view = new DataView(ab);

  function writeStr(off, str){
    for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i));
  }

  writeStr(0, "RIFF");
  view.setUint32(4, 36 + dataSize, true);
  writeStr(8, "WAVE");
  writeStr(12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numCh, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true);
  writeStr(36, "data");
  view.setUint32(40, dataSize, true);

  let offset = 44;
  for(let i=0;i<pcm16.length;i++, offset+=2){
    view.setInt16(offset, pcm16[i], true);
  }

  return new Blob([ab], { type: "audio/wav" });
}

async function getMergedAudioForItem(it){
  if(!it || it.type !== "audio") return null;
  const sig = getAudioSig(it);
  const cached = audioCache[it.id];
  if(cached && cached.sig === sig && cached.buffer){
    return cached;
  }

  const ctx = await ensureAudioContext();
  if(!ctx) return null;

  const segs = it.segments || [];
  if(segs.length === 0){
    audioCache[it.id] = { sig, buffer: null, duration: 0, wavBlob: null };
    return audioCache[it.id];
  }

  const blobs = [];
  for(const s of segs){
    const b = await idbGetBlob(s.key);
    if(b) blobs.push(b);
  }
  if(blobs.length === 0){
    audioCache[it.id] = { sig, buffer: null, duration: 0, wavBlob: null };
    return audioCache[it.id];
  }

  const decoded = [];
  for(const b of blobs){
    try{
      const buf = await decodeBlobToAudioBuffer(ctx, b);
      decoded.push(buf);
    }catch(e){}
  }
  if(decoded.length === 0){
    audioCache[it.id] = { sig, buffer: null, duration: 0, wavBlob: null };
    return audioCache[it.id];
  }

  const merged = concatAudioBuffers(ctx, decoded);
  const duration = merged ? merged.duration : decoded.reduce((s,b)=> s + b.duration, 0);

  audioCache[it.id] = { sig, buffer: merged, duration, wavBlob: null };
  return audioCache[it.id];
}

function startPlayback(itemId, buffer, offsetSec){
  if(!audioCtx || !buffer) return;

  stopSmartPlayback();

  activePlayingItemId = itemId;
  currentOffset = clamp(offsetSec || 0, 0, buffer.duration);

  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  src.connect(audioCtx.destination);

  playStartCtxTime = audioCtx.currentTime;
  playStartOffset = currentOffset;

  activeSource = src;

  src.onended = () => {
    if(activePlayingItemId === itemId){
      currentOffset = buffer.duration;
      stopSmartPlayback();
      const p = getPuchok(currentPuchokId);
      const it = p ? (p.items||[]).find(x=>x.id===itemId) : null;
      if(it && it.type==="audio") renderAudioViewer(it, currentPuchokId);
    }
  };

  try{
    src.start(0, currentOffset);
  }catch(e){
    stopSmartPlayback();
    return;
  }

  tickUI(itemId, buffer);
}

function pausePlayback(){
  if(!audioCtx || !activeSource) return;
  const elapsed = audioCtx.currentTime - playStartCtxTime;
  currentOffset = Math.min((playStartOffset + elapsed), Number.MAX_SAFE_INTEGER);
  stopSmartPlayback();
}

function isPlayingItem(itemId){
  return !!activeSource && activePlayingItemId === itemId;
}

function getCurrentPlayTime(buffer){
  if(!audioCtx || !buffer) return currentOffset || 0;
  if(activeSource && activePlayingItemId){
    const elapsed = audioCtx.currentTime - playStartCtxTime;
    return clamp(playStartOffset + elapsed, 0, buffer.duration);
  }
  return currentOffset || 0;
}

function tickUI(itemId, buffer){
  if(rafId) cancelAnimationFrame(rafId);
  const slider = document.getElementById("smartSlider");
  const timeEl = document.getElementById("smartTime");
  const playBtn = document.getElementById("btnPlayPause");

  const step = () => {
    if(!isPlayingItem(itemId)){
      rafId = null;
      return;
    }
    const t = getCurrentPlayTime(buffer);
    if(slider){
      slider.value = String(t);
      setRangeFill(slider);
    }
    if(timeEl){
      timeEl.textContent = `${fmtTimeSec(t)} / ${fmtTimeSec(buffer.duration)}`;
    }
    rafId = requestAnimationFrame(step);
  };

  if(playBtn) playBtn.textContent = "Пауза";
  if(timeEl){
    const t = getCurrentPlayTime(buffer);
    timeEl.textContent = `${fmtTimeSec(t)} / ${fmtTimeSec(buffer.duration)}`;
  }
  if(slider) setRangeFill(slider);
  rafId = requestAnimationFrame(step);
}

/** ===========================
 *  AUDIO VIEWER (smart)
 *  =========================== */
async function renderAudioViewer(it, pId){
  if(!it || it.type !== "audio") return;

  const segs = it.segments || [];
  const totalBytes = segs.reduce((s,x)=> s + (x.size || 0), 0);

  const canSmart = canUseWebAudio();
  const mergedInfo = canSmart ? await getMergedAudioForItem(it) : null;
  const duration = (mergedInfo && mergedInfo.duration) ? mergedInfo.duration : 0;

  // persist known duration (so live record timer can start from cumulative)
  if(typeof duration === "number" && duration >= 0){
    const p = getPuchok(pId);
    const ref = getItem(pId, it.id);
    if(p && ref){
      ref.durationSec = duration;
      // save without being too noisy
      p.updatedAt = nowISO();
      ref.updatedAt = nowISO();
      saveDB();
    }
  }

  if(activePlayingItemId !== it.id){
    currentOffset = 0;
  }else{
    currentOffset = clamp(currentOffset, 0, duration || 0);
  }

  const isRecThis = isRecording && currentAudioAppendTarget && currentAudioAppendTarget.itemId === it.id;
  const playing = isPlayingItem(it.id);

  const recLabel = (AUDIO_MODE === "mediarecorder")
    ? (isRecThis ? "Стоп запись" : (segs.length ? "Дозаписать" : "Записать"))
    : (segs.length ? "Дозаписать" : "Записать");

  const smartBlock = canSmart
    ? `
      <div class="audioBar">
        <div class="audioTop">
          <div class="audioBtns">
            <button class="audioBtn audioBtnPrimary" id="btnPlayPause" ${(duration>0 && !isRecThis) ? "" : "disabled"}>${playing ? "Пауза" : "Плей"}</button>
            <button class="audioBtn" id="btnStop" ${(duration>0 && !isRecThis) ? "" : "disabled"}>Стоп</button>
          </div>
          <div class="audioTime" id="smartTime">${fmtTimeSec(getCurrentPlayTime(mergedInfo && mergedInfo.buffer ? mergedInfo.buffer : {duration:duration}))} / ${fmtTimeSec(duration)}</div>
        </div>

        <div class="audioSliderWrap">
          <input class="audioSlider" id="smartSlider" type="range" min="0" max="${duration || 0}" step="0.01" value="${Math.min(currentOffset || 0, duration || 0)}" ${(duration>0 && !isRecThis) ? "" : "disabled"} />
        </div>

        <div class="hint" style="margin-top:10px;">
          Умный плеер: один таймлайн, перемотка работает по всему аудио. Скачивание: WAV одним файлом.
        </div>
      </div>
    `
    : `<div class="empty">Этот браузер не поддерживает WebAudio. Воспроизведение “умным” таймлайном недоступно.</div>`;

  modalViewer.innerHTML = `
    <div class="fileRow">
      <div class="fileMeta">
        <div class="fileName">${escapeHTML(it.title || "Аудио")}</div>
        <div class="fileSub">Сегментов: ${segs.length} • ${fmtBytes(totalBytes)} • ${duration ? ("Длина: " + fmtTimeSec(duration)) : "Длина: —"}</div>
      </div>
      <div class="tagText tagAudio">Аудио</div>
    </div>

    ${smartBlock}

    <div class="viewerActions" style="margin-top:12px;">
      <button class="btnOk" id="btnRec">${recLabel}</button>
      <button class="btnGhost" id="btnDownloadWav" ${(duration>0 && !isRecThis) ? "" : "disabled"}>Скачать WAV</button>
    </div>

    <div class="recLine">
      <div>
        ${isRecThis ? `<div class="recBadge"><span class="dot"></span>Запись…</div>` : ""}
        ${(!hasMediaRecorder() ? `<div class="hint">Запись идёт через системный диктофон (capture), потому что MediaRecorder недоступен.</div>` : "")}
      </div>
      <div class="recTimePill" id="recLiveTime">${isRecThis ? ("Запись: " + fmtTimeSec((it.durationSec||0))) : "Запись: —"}</div>
    </div>
  `;

  // Record button
  document.getElementById("btnRec").onclick = async () => {
    if(AUDIO_MODE === "mediarecorder"){
      if(isRecThis) stopAnyRecordingSafely();
      else await startRecordingToAudioItem(pId, it.id);
    }else{
      pendingAudioTarget = { pId, itemId: it.id };
      audioPicker.value = "";
      audioPicker.click();
    }
  };

  // Smart controls
  const playPauseBtn = document.getElementById("btnPlayPause");
  const stopBtn = document.getElementById("btnStop");
  const slider = document.getElementById("smartSlider");

  if(slider){
    setRangeFill(slider);
    slider.addEventListener("input", () => setRangeFill(slider));
  }

  if(canSmart && mergedInfo && mergedInfo.buffer && !isRecThis){
    await ensureAudioContext();

    if(slider){
      slider.addEventListener("input", () => {
        const v = Number(slider.value || 0);
        currentOffset = v;
        const timeEl = document.getElementById("smartTime");
        if(timeEl){
          timeEl.textContent = `${fmtTimeSec(v)} / ${fmtTimeSec(mergedInfo.buffer.duration)}`;
        }
      });

      slider.addEventListener("change", async () => {
        const v = Number(slider.value || 0);
        currentOffset = v;
        if(isPlayingItem(it.id)){
          await ensureAudioContext();
          startPlayback(it.id, mergedInfo.buffer, currentOffset);
        }
      });
    }

    if(playPauseBtn){
      playPauseBtn.onclick = async () => {
        await ensureAudioContext();
        if(isPlayingItem(it.id)){
          pausePlayback();
          playPauseBtn.textContent = "Плей";
          const timeEl = document.getElementById("smartTime");
          if(timeEl){
            timeEl.textContent = `${fmtTimeSec(currentOffset)} / ${fmtTimeSec(mergedInfo.buffer.duration)}`;
          }
          return;
        }
        startPlayback(it.id, mergedInfo.buffer, currentOffset || 0);
      };
    }

    if(stopBtn){
      stopBtn.onclick = () => {
        pausePlayback();
        currentOffset = 0;
        if(slider){ slider.value = "0"; setRangeFill(slider); }
        const timeEl = document.getElementById("smartTime");
        if(timeEl){
          timeEl.textContent = `${fmtTimeSec(0)} / ${fmtTimeSec(mergedInfo.buffer.duration)}`;
        }
        if(playPauseBtn) playPauseBtn.textContent = "Плей";
      };
    }
  }else{
    if(playPauseBtn) playPauseBtn.disabled = true;
    if(stopBtn) stopBtn.disabled = true;
    if(slider) slider.disabled = true;
  }

  // Download WAV
  const btnWav = document.getElementById("btnDownloadWav");
  if(btnWav){
    btnWav.onclick = async () => {
      const info = await getMergedAudioForItem(it);
      if(!info || !info.buffer){
        alert("Не удалось собрать аудио для WAV.");
        return;
      }
      if(!info.wavBlob){
        info.wavBlob = audioBufferToWavBlob(info.buffer);
        audioCache[it.id] = info;
      }
      const url = URL.createObjectURL(info.wavBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = (it.title || "audio") + ".wav";
      a.click();
      setTimeout(()=> URL.revokeObjectURL(url), 1000);
    };
  }

  // If recording for this item is active but clock not running (e.g., rerender), restart it
  if(isRecThis){
    const baseSec = Number(it.durationSec || (audioCache[it.id]?.duration) || 0);
    startRecClock(it.id, baseSec);
  }else{
    const recEl = document.getElementById("recLiveTime");
    if(recEl) recEl.textContent = "Запись: —";
  }
}

/** ===========================
 *  CHAT UI
 *  =========================== */
function addMsg(text, cls){
  const wrap = document.createElement("div");
  wrap.className = "msg " + cls;

  const body = document.createElement("div");
  body.textContent = text;
  wrap.appendChild(body);

  if(cls === "bot"){
    const tools = document.createElement("div");
    tools.className = "msgTools";

    const btnSave = document.createElement("button");
    btnSave.className = "miniBtn miniBtnOk";
    btnSave.textContent = "В пучок";
    btnSave.addEventListener("click", () => {
      if(!currentPuchokId){
        alert("Открой пучок — тогда “В пучок” сохранит ответ туда.");
        return;
      }
      addTextItemToCurrent(text);
    });

    tools.appendChild(btnSave);
    wrap.appendChild(tools);
  }

  chat.appendChild(wrap);
  chat.scrollTop = chat.scrollHeight;
}

function clearChat(){
  chat.innerHTML = "";
  addMsg("Чат очищен. Пиши сообщение — я отправлю в Worker (/chat).", "bot");
}

/** ===========================
 *  CHAT NETWORK
 *  =========================== */
async function handleSend(){
  const text = input.value.trim();
  if(!text) return;

  expandChat();
  addMsg(text, "me");
  input.value = "";
  send.disabled = true;

  try{
    const resp = await fetch(WORKER_URL + "/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: text })
    });

    const raw = await resp.text();
    let data = {};
    try{ data = JSON.parse(raw); }catch{}

    if(!resp.ok){
      addMsg(`HTTP ${resp.status}: ${raw || "error"}`, "err");
    }else if(data && data.ok){
      addMsg(data.answer || "Нет ответа", "bot");
    }else{
      addMsg(raw || "Неожиданный ответ", "err");
    }
  }catch(e){
    addMsg("Ошибка сети: " + (e?.message || e), "err");
  }

  send.disabled = false;
}

/** ===========================
 *  EVENTS
 *  =========================== */
backBtn.addEventListener("click", goBack);
newPuchokBtn.addEventListener("click", createPuchok);

editPuchokBtn.addEventListener("click", () => {
  closeAddMenu();
  renameCurrentPuchok();
});

addMenuBtn.addEventListener("click", (e)=>{
  e.stopPropagation();
  toggleAddMenu();
});

menuAddText.addEventListener("click", ()=>{
  closeAddMenu();
  addTextItemToCurrent("");
});

menuAddFile.addEventListener("click", ()=>{
  closeAddMenu();
  if(!currentPuchokId){ alert("Сначала открой пучок."); return; }
  filePicker.value = "";
  filePicker.click();
});

menuAddAudio.addEventListener("click", async ()=>{
  closeAddMenu();
  if(!currentPuchokId){ alert("Сначала открой пучок."); return; }
  await createAudioItemAndRecord();
});

menuDeletePuchok.addEventListener("click", async ()=>{
  await deleteCurrentPuchok();
});

filePicker.addEventListener("change", async () => {
  const f = filePicker.files && filePicker.files[0];
  if(!f) return;
  await addFileItemToCurrent(f);
});

audioPicker.addEventListener("change", async ()=>{
  const f = audioPicker.files && audioPicker.files[0];
  if(!f || !pendingAudioTarget) return;

  const target = pendingAudioTarget;
  pendingAudioTarget = null;

  await appendAudioSegmentFromBlob(target.pId, target.itemId, f, f.name || "audio");
});

send.addEventListener("click", handleSend);
input.addEventListener("keydown", (e) => { if(e.key === "Enter") handleSend(); });
clearChatBtn.addEventListener("click", clearChat);

modalClose.addEventListener("click", closeModal);
modalWrap.addEventListener("click", (e)=>{ if(e.target === modalWrap) closeModal(); });
modalSave.addEventListener("click", saveModal);
modalDelete.addEventListener("click", deleteModal);

document.addEventListener("click", ()=> closeAddMenu());
addMenu.addEventListener("click", (e)=> e.stopPropagation());

/** ===========================
 *  INIT
 *  =========================== */
(function init(){
  AUDIO_MODE = chooseAudioMode();
  render();
  clearChat();
  collapseChat();
})();
</script>
</body>
</html>
